{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MoonLight","text":"<p>MoonLight is software which runs on ESP32 microcontrollers providing a web-browser interface to control lights in particular and any IOT service in general. ESP32 devices can be connected to your local network via WiFi or Ethernet, Moonlight can be controlled via a web browser selecting the IP-address or network name of the device. MoonLight can be installed on ESP32 by means of a web installer or if you are a developer, via Visual Studio Code with the PlatformIO plugin installed.</p> <p>MoonLight's core functionality is called MoonBase, Lighting specific functionality is called MoonLight. MoonLight is a stand alone product for end users controlling lights but Moonlight can also be used to create a custom IOT service by creating a github fork of MoonLight, rename it to the service, switching off the MoonLight feature and build your own functionality. This can be as simple as creating a smart plug or a timer or temperature sensor or as complex as for instance a greenhouse management system, using the ESP32 hardware interfaces (via GPIO ports) or it's network communication protocols.</p> <p>Examples of Moonbase functionality are monitor and manage a device, manage WiFi, Firmware updates, System Status and Restart. On top of that there is a file manager and an instance manager.</p> <p>MoonLight functionality is aimed at running effects on multiple lights. It's primarely focused on LED strips or LED panels but also DMX lights can be controlled via Art-Net. Depending on the type of ESP32 used and the amount of memory available, the number of LEDs can go up to 12288 at 120 FPS! Even more LEDs are possible, upon 65K at lower framerates. Also a large number of DMX lights can be controlled. MoonLight works with virtual and physical layers of lights and contains a node based model where nodes can be light layouts, effects and modifiers and run effects on a virtual layer and map the effect onto physical lights. </p> <p></p> <p>MoonLight is a MoonModules.org project. MoonModules is a group of lighting enthusiasts who also made WLED MM and contribute to WLED. Where WLED (MM) is aimed at 1D and 2D effects and LED setups, MoonLight is build to support 2D and 3D effects and multiple light setups. MoonLight has been built from scratch using the experience gained working on WLED (MM).</p> <ul> <li>Latest release can be found here. Release v0.5.6 is a developer release and works towards MoonLight 0.6.0 which is aimed at end users and is expected in September 2025. Containing presets controller pad, user friendly installer, physical and virtual driver for large displays, WLED audio sync and more.</li> <li>Progress can be tracked in the Kanban board</li> <li>Get started here</li> <li>Follow us on Discord/MoonLight or Reddit.</li> <li>See Star-Mod-Base-Light-Moon-Svelte-Live how MoonLight evolved from StarMod, StarBase, StarLight, MoonBase. </li> <li>Documentation see MoonLightDocs.</li> <li>We need developers: to create new layouts, effects and modifiers, to create ci-automations, to connect Midi controllers, to make web installers, to improve the UI or whatever good idea you have. Contact us on Discord or Reddit if you want to help!</li> <li>If you appreciate this project, a star on the repo would be awesome: </li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>MoonLight uses the following repositories:</p> <ul> <li>theelims/ESP32-sveltekit: MoonLight is a fork of ESP32-sveltekit. A simple and extensible framework for ESP32 based IoT projects with a feature-rich, beautiful, and responsive front-end build with Sveltekit, TailwindCSS and DaisyUI. It provides a powerful back end service, an amazing front end served from the ESP32 and an easy to use build chain to get everything going. See also ESP32-sveltekit POC where the idea of MoonLight on ESP32SvelteKit started</li> <li>hoeken/PsychicHttp: PsychicHttp is a webserver library for ESP32 + Arduino framework which uses the ESP-IDF HTTP Server library under the hood.</li> <li>theelims/PsychicMqttClient: Fully featured async MQTT 3.1.1 client for ESP32 with support for SSL/TLS and MQTT over WS. Uses the ESP-IDF MQTT client library under the hood and adds a powerful but easy to use API on top of it. Supports MQTT over TCP, SSL with mbedtls, MQTT over Websocket and MQTT over Websocket Secure.</li> <li>bblanchon/ArduinoJson: ArduinoJson is a C++ JSON library for Arduino and IoT (Internet Of Things).</li> <li>FastLED/FastLED: FastLED is a robust and massively parallel-led driver. Due to it's incredibly small compile size, high end devices can drive upto ~20k on ESP32. Supports nearly every single LED chipset in existence. Background rendering means you can respond to user input while the leds render.</li> <li>hpwit/ESPLiveScript: execute programs on the esp32 without having to load the code via any IDE (Arduino, VSCode)</li> <li>hpwit/I2SClocklessLedDriver: This library is a new take on driving ws2812 leds with I2S on an esp32. It allows to drive up to 16 LED strips in parallel</li> <li>/hpwit/I2SClocklessVirtualLedDriver: This library is a new take on driving ws2812 leds with I2S on an esp32. It allows to drive up to 120 LED strips !!! in parallel</li> <li>netmindz/WLED-sync: Library to create WLED compatible projects that sync their audio</li> </ul> <p></p>"},{"location":"#license","title":"License","text":"<p>MoonBase, MoonLight \u2696\ufe0f GPL-v3</p> <p>If you are an individual user and want to support the development or if you run a commercial project using MoonLight, think about sponsoring MoonLight development: it ensures the code your products rely on stays actively maintained. We can also give your project exposure to the MoonLight community by listing it on this page.</p> <p>https://github.com/sponsors/ewowi PayPal</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Using this software is the users responsibility as it is not bug free. Therefore contributors of this repo are not reliable for anything including but not limited to spontaneous combustion of the entire led strip, the house and the inevitable heat death of the universe</p>"},{"location":"buildprocess/","title":"Build Process","text":"<p>The build process is controlled by platformio.ini and automates the build of the front end website with Vite as well as the binary compilation for the ESP32 firmware. Whenever PlatformIO is building a new binary it will call the python script build_interface.py to action. It will check the frontend files for changes. If necessary it will start the Vite build and gzip the resulting files either to the <code>data/</code> directory or embed them into a header file. In case the WWW files go into a LITTLEFS partition a file system image for the flash is created for the default build environment and upload to the ESP32.</p>"},{"location":"buildprocess/#changing-the-js-package-manager","title":"Changing the JS package manager","text":"<p>This project uses NPM as the default package manager. However, many users might have different preferences and like to use YARN or PNPM instead. Just switch the interface to one of the other package managers. The build script identify the package manager by the presence of its lock-file and start the vite build process accordingly.</p>"},{"location":"buildprocess/#serving-from-flash-or-embedding-into-the-binary","title":"Serving from Flash or Embedding into the Binary","text":"<p>The front end website can be served either from the LITTLEFS partition of the flash, or embedded into the firmware binary (default). Later has the advantage that only one binary needs to be distributed easing the OTA process. Further more this is desirable if you like to preserve the settings stored in the LITTLEFS partition, or have other files there that need to survive a firmware update. To serve from the LITTLEFS partition instead please comment the following build flag out:</p> <pre><code>build_flags =\n    ...\n    -D EMBED_WWW\n</code></pre>"},{"location":"buildprocess/#partitioning","title":"Partitioning","text":"<p>If you choose to embed the frontend it becomes part of the firmware binary (default). As many ESP32 modules only come with 4MB built-in flash this results in the binary being too large for the reserved flash. Therefor a partition scheme with a larger section for the executable code is selected. However, this limits the LITTLEFS partition to 200kb. There are a great number of default partition tables for Arduino-ESP32 to choose from. If you have 8MB or 16MB flash this would be your first choice. If you don't need OTA you can choose a partition scheme without OTA.</p> <p>Should you want to deploy the frontend from the flash's LITTLEFS partition on a 4MB chip you need to comment out the following two lines. Otherwise the 200kb will not be large enough to host the front end code.</p> <pre><code>board_build.partitions = min_spiffs.csv\n</code></pre>"},{"location":"buildprocess/#selecting-features","title":"Selecting Features","text":"<p>Many of the framework's built in features may be enabled or disabled as required at compile time. This can help save sketch space and memory if your project does not require the full suite of features. The access point and WiFi management features are \"core features\" and are always enabled. Feature selection may be controlled with the build flags defined in features.ini.</p> <p>Customize the settings as you see fit. A value of 0 will disable the specified feature:</p> <pre><code>  -D FT_SECURITY=1\n  -D FT_MQTT=1\n  -D FT_NTP=1\n  -D FT_UPLOAD_FIRMWARE=1\n  -D FT_DOWNLOAD_FIRMWARE=1\n  -D FT_SLEEP=1\n  -D FT_BATTERY=1\n</code></pre> Flag Description FT_SECURITY Controls whether the security features are enabled. Disabling this means you won't need to authenticate to access the device and all authentication predicates will be bypassed. FT_MQTT Controls whether the MQTT features are enabled. Disable this if your project does not require MQTT support. FT_NTP Controls whether network time protocol synchronization features are enabled. Disable this if your project does not require accurate time. FT_UPLOAD_FIRMWARE Controls whether the manual upload firmware feature is enabled. Disable this if you won't be manually uploading firmware. FT_DOWNLOAD_FIRMWARE Controls whether the firmware download feature is enabled. Disable this if you won't firmware pulled from a server. FT_SLEEP Controls whether the deep sleep feature is enabled. Disable this if your device is not battery operated or you don't need to place it in deep sleep to save energy. FT_BATTERY Controls whether the battery state of charge shall be reported to the clients. Disable this if your device is not battery operated. <p>In addition custom features might be added or removed at runtime. See Custom Features on how to use this in your application.</p>"},{"location":"buildprocess/#factory-settings","title":"Factory Settings","text":"<p>The framework has built-in factory settings which act as default values for the various configurable services where settings are not saved on the file system. These settings can be overridden using the build flags defined in factory_settings.ini. All strings entered here must be escaped, especially special characters.</p> <p>Customize the settings as you see fit, for example you might configure your home WiFi network as the factory default:</p> <pre><code>  -D FACTORY_WIFI_SSID=\\\"My\\ Awesome\\ WiFi\\ Network\\\"\n  -D FACTORY_WIFI_PASSWORD=\\\"secret\\\"\n  -D FACTORY_WIFI_HOSTNAME=\\\"awesome_light_controller\\\"\n</code></pre>"},{"location":"buildprocess/#default-access-point-settings","title":"Default access point settings","text":"<p>By default, the factory settings configure the device to bring up an access point on start up which can be used to configure the device:</p> <ul> <li>SSID: ESP32-Sveltekit</li> <li>Password: esp-sveltekit</li> </ul>"},{"location":"buildprocess/#security-settings-and-user-credentials","title":"Security settings and user credentials","text":"<p>By default, the factory settings configure two user accounts with the following credentials:</p> Username Password admin admin guest guest <p>It is recommended that you change the user credentials from their defaults to better protect your device. You can do this in the user interface, or by modifying factory_settings.ini as mentioned above.</p>"},{"location":"buildprocess/#customizing-the-factory-time-zone-setting","title":"Customizing the factory time zone setting","text":"<p>Changing factory time zone setting is a common requirement. This requires a little effort because the time zone name and POSIX format are stored as separate values for the moment. The time zone names and POSIX formats are contained in the UI code in timezones.ts. Take the appropriate pair of values from there, for example, for Los Angeles you would use:</p> <pre><code>  -D FACTORY_NTP_TIME_ZONE_LABEL=\\\"America/Los_Angeles\\\"\n  -D FACTORY_NTP_TIME_ZONE_FORMAT=\\\"PST8PDT,M3.2.0,M11.1.0\\\"\n</code></pre>"},{"location":"buildprocess/#placeholder-substitution","title":"Placeholder substitution","text":"<p>Various settings support placeholder substitution, indicated by comments in factory_settings.ini. This can be particularly useful where settings need to be unique, such as the Access Point SSID or MQTT client id. The following placeholders are supported:</p> Placeholder Substituted value #{platform} The microcontroller platform, e.g. \"esp32\" or \"esp32c3\" #{unique_id} A unique identifier derived from the MAC address, e.g. \"0b0a859d6816\" #{random} A random number encoded as a hex string, e.g. \"55722f94\""},{"location":"buildprocess/#other-build-flags","title":"Other Build Flags","text":""},{"location":"buildprocess/#cross-origin-resource-sharing","title":"Cross-Origin Resource Sharing","text":"<p>If you need to enable Cross-Origin Resource Sharing (CORS) on the ESP32 server just uncomment the following build flags:</p> <pre><code>build_flags =\n...\n  ; Uncomment to configure Cross-Origin Resource Sharing\n  -D ENABLE_CORS\n  -D CORS_ORIGIN=\\\"*\\\"\n</code></pre> <p>This will add the <code>Access-Control-Allow-Origin</code> and <code>Access-Control-Allow-Credentials</code> headers to any request made.</p>"},{"location":"buildprocess/#esp32-core_debug_level","title":"ESP32 <code>CORE_DEBUG_LEVEL</code>","text":"<p>The ESP32 Arduino Core and many other libraries use the ESP Logging tools. To enable these debug and error messages from deep inside your libraries uncomment the following build flag.</p> <pre><code>build_flags =\n...\n    -D CORE_DEBUG_LEVEL=5\n</code></pre> <p>It accepts values from 5 (Verbose) to 1 (Errors) for different information depths to be logged on the serial terminal. If commented out there won't be debug messages from the core libraries. For a production build you should comment this out.</p>"},{"location":"buildprocess/#serve-config-files","title":"Serve Config Files","text":"<p>By enabling this build flag the ESP32 will serve all config files stored on the LittleFS flash partition under <code>http:\\\\[IP]\\config\\[filename].json</code>. This can be helpful to troubleshoot problems. However, it is strongly advised to disable this for production builds.</p> <pre><code>build_flags =\n...\n  -D SERVE_CONFIG_FILES\n</code></pre>"},{"location":"buildprocess/#serial-info","title":"Serial Info","text":"<p>In some circumstances it might be beneficial to not print any information on the serial consol (Serial1 or USB CDC). By commenting out the following build flag ESP32-Sveltekit will not print any information on the serial console.</p> <pre><code>build_flags =\n...\n  -D SERIAL_INFO\n</code></pre>"},{"location":"buildprocess/#ssl-root-certificate-store","title":"SSL Root Certificate Store","text":"<p>Some features like firmware download or the MQTT client require a SSL connection. For that the SSL Root CA certificate must be known to the ESP32. The build system contains a python script derived from Espressif ESP-IDF building a certificate store containing one or more certificates. In order to create the store you must uncomment the three lines below in <code>platformio.ini</code>.</p> <pre><code>extra_scripts =\n    pre:scripts/generate_cert_bundle.py\nboard_build.embed_files = src/certs/x509_crt_bundle.bin\nboard_ssl_cert_source = adafruit\n</code></pre> <p>The script will download a public certificate store from Mozilla (<code>board_ssl_cert_source = mozilla</code>) or a repository curated by Adafruit (<code>board_ssl_cert_source = adafruit</code>), builds a binary containing all certs and embeds this into the firmware. This will add ~65kb to the firmware image. Should you only need a few known certificates you can place their <code>*.pem</code> or <code>*.der</code> files in the ssl_certs folder and change <code>board_ssl_cert_source = folder</code>. Then only these certificates will be included in the store. This is especially useful, if you only need to connect to know servers and need to shave some kb off the firmware image:</p> <p>Info</p> <p>To enable SSL the feature <code>FT_NTP=1</code> must be enabled as well.</p>"},{"location":"buildprocess/#vite-and-littlefs-32-character-limit","title":"Vite and LittleFS 32 Character Limit","text":"<p>The static files for the website are build using vite. By default vite adds a unique hash value to all filenames for improved caching performance. However, LittleFS on the ESP32 is limited to filenames with 32 characters. This restricts the number of characters available for the user to name svelte files. To give a little bit more headroom a vite-plugin removes all hash values, as they offer no benefit on an ESP32. However, have the 32 character limit in mind when naming files. Excessively long names may still cause some issues when building the LittleFS binary.</p>"},{"location":"buildprocess/#merged-firmware-file-for-web-flasher","title":"Merged Firmware File for Web Flasher","text":"<p>The PIO build system calls a script <code>merge_bin.py</code> to create a merged firmware binary ready to be used with ESP Web Tools. The file is located under the PIO build folder. Typically <code>build/merged/{APP_NAME}_{$PIOENV}_{APP_VERSION}.bin</code>.</p>"},{"location":"components/","title":"Components","text":"<p>The project includes a number of components to create the user interface. Even though DaisyUI has a huge set of components, it is often beneficial to recreate them as a Svelte component. This offers a much better integration into the Svelte way of doing things, is less troublesome with animations and results in a overall better user experience.</p>"},{"location":"components/#collapsible","title":"Collapsible","text":"<p>A collapsible container to hide / show content by clicking on the arrow button.</p> <pre><code>import Collapsible from \"$lib/components/Collapsible.svelte\";\n</code></pre> <p>It exports a closed / open state with <code>export open</code> which you can use to determine the mounting behavior of the component.</p>"},{"location":"components/#slots","title":"Slots","text":"<p>The component has two slots. A named slot <code>title</code> for the collapsible title and the main slot for the content that can be hidden or shown.</p> <pre><code>&lt;Collapsible open={false} class=\"shadow-lg\" on:closed={doSomething}&gt;\n  &lt;span slot=\"title\"&gt;Title&lt;/span&gt;\n  ...\n&lt;/Collapsible&gt;\n</code></pre> <p>The <code>class</code> attribute may be used as normal to style the container. By default there is no special styling like background or shadows to accentuate the container element.</p>"},{"location":"components/#events","title":"Events","text":"<p>The collapsible component dispatches two events. <code>on:closed</code> when the collapsible is closed and <code>on:opened</code> when it is opened. You can bind to them as to any other event.</p>"},{"location":"components/#inputpassword","title":"InputPassword","text":"<p>This is an input field specifically for passwords. It comes with an \"eye\"-button on the right border to toggle the visibility of the password. It natively blends into the style from DaisyUI.</p> <pre><code>import InputPassword from \"$lib/components/InputPassword.svelte\";\n</code></pre> <p>You may use it like any other form element:</p> <pre><code>&lt;InputPassword id=\"pwd\" bind:value={password} /&gt;\n</code></pre>"},{"location":"components/#rssiindicator","title":"RSSIIndicator","text":"<p>This shows the popular WiFi strength indicator icon with differently highlighted circles depending on the received signal strength (RSSI) of the WiFi signal. In addition it can display the signal strength in raw \"dBm\" as an indicator badge.</p> <pre><code>import RssiIndicator from \"$lib/components/RSSIIndicator.svelte\";\n</code></pre> <p>Just use and style as you please. It doesn't have any slots or events.</p> <pre><code>&lt;RssiIndicator showDBm={true} rssi_dbm={-85} class=\"text-base-content h-10 w-10\" /&gt;\n</code></pre> <p>Two exports control the behavior of the component. <code>rssi_dbm</code> accepts a negative number of the raw RSSI in dBm and is used to determine how many circles of reception should be shown. An optional boolean <code>showDBm</code> (defaults to <code>false</code>) shows the indicator badge with the dBm value.</p>"},{"location":"components/#settings-card","title":"Settings Card","text":"<p>A Settings Card is in many ways similar to a collapsible. However, it is styled and is the main element of many settings menus. It also accepts an icon in a dedicate slot and unlike collapsible has no events.</p> <pre><code>import SettingsCard from \"$lib/components/SettingsCard.svelte\";\n</code></pre>"},{"location":"components/#slots_1","title":"Slots","text":"<p>Three slots are available. Besides the main slot for the content there is a named slot for the <code>title</code> and s second one for the <code>icon</code>.</p> <pre><code>&lt;SettingsCard collapsible={true} open={false}&gt;\n    &lt;Icon slot=\"icon\" class=\"lex-shrink-0 mr-2 h-6 w-6 self-end\" /&gt;\n    &lt;span slot=\"title\"&gt;Title&lt;/span&gt;\n    ...\n&lt;/SettingsCard&gt;\n</code></pre> <p>The component exports two properties to determine its behavior. <code>collapsible</code> is a boolean describing wether the component should behave like a collapsible in the first place. <code>open</code> is a boolean as well and if set true shows the full content of the body on mount.</p>"},{"location":"components/#spinner","title":"Spinner","text":"<p>A small component showing an animated spinner which can be used while waiting for data.</p> <pre><code>import Spinner from \"$lib/components/Spinner.svelte\";\n</code></pre> <p>No slots, no events, no properties. Just use <code>&lt;Spinner/&gt;</code> whenever something is loading.</p>"},{"location":"components/#toast-notifications","title":"Toast Notifications","text":"<p>Toast notifications are implemented as a writable store and are easy to use from any script section. They are an easy way to feedback to the user. To use them just import the notifications store</p> <pre><code>import { notifications } from \"$lib/components/toasts/notifications\";\n</code></pre> <p>and call one of the 4 toast methods:</p> Method Description <code>notification.error(msg:string, timeout:number)</code>  Shows an error message <code>notification.warning(msg:string, timeout:number)</code>  Shows a warning message <code>notification.info(msg:string, timeout:number)</code>  Shows an info message <code>notification.success(msg:string, timeout:number)</code>  Shows as success message <p>Each method takes an <code>msg</code>-string as an argument, which will be shown as the message body. It accepts HTML to enrich your toasts, if you should desire to do so. The <code>timeout</code> argument specifies how many milliseconds the toast notification shall be shown to the user.</p>"},{"location":"components/#github-update-dialog","title":"Github Update Dialog","text":"<p>This is a modal showing the update progress, possible error messages and makes a full page refresh 5 seconds after the OTA was successful.</p>"},{"location":"components/#update-indicator","title":"Update Indicator","text":"<p>The update indicator is a small widget shown in the upper right corner of the status bar. It indicates the availability of a newer firmware release then the current one. Upon pressing the icon it will automatically update the firmware to the latest release. By default this works through the Github Latest Release API. This must be customized should you use a different update server. Have a look at the source file to see what portions to update.</p>"},{"location":"components/#info-dialog","title":"Info Dialog","text":"<p>Shows a modal on the UI which must be deliberately dismissed. It features a <code>title</code> and a <code>message</code> property. The dismiss button can be customized via the <code>dismiss</code> property with a label and an icon. <code>onDismiss</code> call back must close the modal and can be used to do something when closing the info dialog.</p> <pre><code>import InfoDialog from \"$lib/components/InfoDialog.svelte\";\n\nmodals.open(InfoDialog, {\n  title: 'You have a new Info',\n  message:\n    'Something really important happened that justifies showing you a modal which must be clicked away.',\n  dismiss: { label: 'OK', icon: Check },\n  onDismiss: () =&gt; modals.close();\n});\n</code></pre> <p>This modal is based on svelte-modals where you can find further information.</p>"},{"location":"components/#confirm-dialog","title":"Confirm Dialog","text":"<p>Shows a confirm modal on the UI which must be confirmed to proceed, or can be canceled. It features a <code>title</code> and a <code>message</code> property. The <code>confirm</code> and <code>cancel</code> buttons can be customized via the <code>labels</code> property with a label and an icon. <code>onConfirm</code> call back must close the modal and can be used to trigger further actions.</p> <pre><code>import ConfirmDialog from \"$lib/components/ConfirmDialog.svelte\";\n\nmodals.open(ConfirmDialog, {\n  title: \"Confirm what you are doing\",\n  message: \"Are you sure you want to proceed? This could break stuff!\",\n  labels: {\n    cancel: { label: \"Abort\", icon: Cancel },\n    confirm: { label: \"Confirm\", icon: Check },\n  },\n  onConfirm: () =&gt; modals.close(),\n});\n</code></pre> <p>This modal is based on svelte-modals where you can find further information.</p> <p>\ud83c\udf19</p>"},{"location":"components/#moonbase-components","title":"MoonBase components","text":""},{"location":"components/#multiinput","title":"MultiInput","text":""},{"location":"components/#array","title":"Array","text":"<ul> <li>Show an array of objects<ul> <li>Summary and editor</li> </ul> </li> <li>Recursive<ul> <li>An array can have an array e.g. multiple nodes with multiple controls per node</li> </ul> </li> <li>Uses MultiInput</li> <li>Used data and definition rest apis</li> </ul>"},{"location":"components/#fileedit","title":"FileEdit","text":"<p>Arguments</p> <ul> <li>path: file or folder to edit</li> <li>showEditor: collapsed or not</li> <li>newItem</li> <li>isFile: or folder</li> </ul> <p>Functions</p> <ul> <li>postFilesState / uploadFile</li> <li>getFileContents</li> <li>$: if (editableFile.path != path): reactive</li> <li>onSave (-&gt;postFilesState)</li> </ul>"},{"location":"esp32sveltekit/","title":"ESP32 SvelteKit - Create Amazing IoT Projects","text":"<p>A simple and extensible framework for ESP32 based IoT projects with a feature-rich, beautiful, and responsive front-end build with Sveltekit, TailwindCSS and DaisyUI. This is a project template to get you started in no time backed by a powerful back end service, an amazing front end served from the ESP32 and an easy to use build chain to get everything going.</p> <p>It was forked from the fabulous rjwats/esp8266-react project, from where it inherited the mighty back end services.</p> <p>Info</p> <p>This template repository is not meant to be used stand alone. If you're just looking for a WiFi manager there are plenty of options available. This is a starting point when you need a rich web UI.</p>"},{"location":"esp32sveltekit/#features","title":"Features","text":""},{"location":"esp32sveltekit/#beautiful-ui-powered-by-daisyui-and-tailwindcss","title":"Beautiful UI powered by DaisyUI and TailwindCSS","text":"<p>Beautiful, responsive UI which works equally well on desktop and on mobile. Gently animated for a snappy and modern feeling without ever being obtrusive or in the way. Easy theming with DaisyUI and media-queries to respect the users wish for a light or dark theme.</p>"},{"location":"esp32sveltekit/#low-memory-footprint-and-easy-customization-by-courtesy-of-sveltekit","title":"Low Memory Footprint and Easy Customization by Courtesy of SvelteKit","text":"<p>SvelteKit is ideally suited to be served from constrained devices like an ESP32. It's unique approach leads to very slim files. No bloatware like other popular JS frameworks. Not only the low memory footprint make it ideal but the developer experience is also outstanding letting you customize the front end with ease. Adapt and add functionality as you need it. The back end has you covered as well.</p>"},{"location":"esp32sveltekit/#rich-communication-interfaces","title":"Rich Communication Interfaces","text":"<p>Comes with a rich set of communication interfaces to cover most standard needs of an IoT application. Like MQTT client, HTTP RESTful API, a WebSocket based Event Socket and a classic Websocket Server. All communication channels are stateful and fully synchronized. Changes propagate and are communicated to all other participants. The states can be persisted on the file system as well. For accurate time keeping time can by synchronized over NTP.</p>"},{"location":"esp32sveltekit/#wifi-provisioning-and-management","title":"WiFi Provisioning and Management","text":"<p>Naturally ESP32 SvelteKit comes with rich features to manage all your WiFi needs. From pulling up an access point for provisioning or as fall back, to fully manage your WiFi networks. Scan for available networks and connect to them. Advanced configuration options like static IP are on board as well.</p>"},{"location":"esp32sveltekit/#secured-api-and-user-management","title":"Secured API and User Management","text":"<p>Manage different user of your app with two authorization levels. An administrator and a guest user. Authenticate their API calls with a JWT token. Manage the user's profile from the admin interface. Use at own risk, as it is neither secure without the ability to use TLS/SSL encryption on the ESP32 server, nor very convenient, as only an admin can change passwords.</p>"},{"location":"esp32sveltekit/#ota-upgrade-service","title":"OTA Upgrade Service","text":"<p>The framework can provide two different channels for Over-the-Air updates. Either by uploading a *.bin file from the web interface. Or by pulling a firmware image from an update server. This is implemented with the github release page as an example. It is even possible to have different build environments at the same time and the Github OTA process pulls the correct binary.</p>"},{"location":"esp32sveltekit/#automated-build-chain","title":"Automated Build Chain","text":"<p>The automated build chain takes out the pain and tears of getting all the bits and pieces play nice together. The repository contains a PlatformIO project at its heart. A SvelteKit project for the frontend code and a mkdocs project for the documentation go alongside. The PlatformIO build tools not only build the SvelteKit frontend with Vite, but also ensure that the build results are gzipped and find their way into the flash memory of the ESP32. You have two choices to serve the frontend either from the flash partition, or embedded into the firmware binary. The latter is much more friendly if your frontend code should be distributed OTA as well, leaving all configuration files intact.</p>"},{"location":"esp32sveltekit/#compatible-with-all-esp32-flavours","title":"Compatible with all ESP32 Flavours","text":"<p>The code runs on all variants of the ESP32 chip family. From the plain old ESP32, the ESP32-S3 and ESP32-C3. Other ESP32 variants might work, but haven't been tested. Sorry, no support for the older ESP8266. Go with one of the ESP32's instead.</p> <p>Let's get started!</p>"},{"location":"esp32sveltekit/#license","title":"License","text":"<p>ESP32 SvelteKit is distributed with two licenses for different sections of the code. The back end code inherits the GNU LESSER GENERAL PUBLIC LICENSE Version 3 and is therefore distributed with said license. The front end code is distributed under the MIT License. See the LICENSE for a full text of both licenses.</p>"},{"location":"gettingstarted/","title":"Getting Started","text":""},{"location":"gettingstarted/#prerequisites","title":"Prerequisites","text":"<p>This project has quite a complicated build chain to prepare the frontend code for the ESP32. You will need to install some tools to make this all work, starting with a powerful code editor.</p>"},{"location":"gettingstarted/#softwares-to-install","title":"Softwares to Install","text":"<p>Please install the following software, if you haven't already:</p> <ul> <li>VSCode - IDE for development</li> <li>Node.js - For building the interface with npm</li> </ul>"},{"location":"gettingstarted/#vscode-plugins-and-setups","title":"VSCode Plugins and Setups","text":"<p>Please install the following mandatory VSCode Plugins:</p> <ul> <li>PlatformIO - Embedded development platform</li> <li>Prettier - Automated code formatter</li> <li>Svelte for VS Code - Makes working with Svelte much easier</li> <li>Svelte Intellisense - Another Svelte tool</li> <li>Tailwind CSS Intellisense - Makes working with Tailwind CSS much easier</li> <li>Prettier plugin for Tailwind CSS - Automatically sorts the Tailwind classes into their recommended order</li> </ul> <p>Lastly, if you want to make use of Materials for MkDocs as your documentation engine, install Material for MkDocs by typing the following into the VSCode terminal:</p> <pre><code>pip install mkdocs-material\n</code></pre> <p>Tip</p> <p>You might need to run this as administrator, if you getting an error message.</p>"},{"location":"gettingstarted/#project-structure","title":"Project Structure","text":"Resource Description .github/ Github CI pipeline to deploy MkDocs to gh-pages docs/ MkDocs documentation files interface/ SvelteKit based front end lib/framework/ C++ back end for the ESP32 device src/ The main.cpp and demo project to get you started scripts/ Scripts that build the interface as part of the platformio build platformio.ini PlatformIO project configuration file mkdocs.yaml MkDocs project configuration file"},{"location":"gettingstarted/#setting-up-platformio","title":"Setting up PlatformIO","text":""},{"location":"gettingstarted/#setup-build-target","title":"Setup Build Target","text":"<p>Do not use the PlatformIO UI for editing platformio.ini</p> <p>It is tempting to use the PlatformIO user interface to add dependencies or parameters to platformio.ini. However, doing so will remove all \"irrelevant\" information like comments from the file. Please edit the file directly in the editor.</p> <p>platformio.ini is the central file controlling the whole build process. It comes pre-configure with a few boards which have different ESP32 chips. It needs to be adapted to the board you want to program.</p> <pre><code>[platformio]\n...\ndefault_envs = esp32-s3-devkitc-1\n...\n\n[env:adafruit_feather_esp32_v2]\nboard = adafruit_feather_esp32_v2\nboard_build.mcu = esp32\n\n[env:lolin_c3_mini]\nboard = lolin_c3_mini\nboard_build.mcu = esp32c3\n\n[env:esp32-s3-devkitc-1]\nboard = esp32-s3-devkitc-1\nboard_build.mcu = esp32s3\n</code></pre> <p>If your board is not listed in the platformio.ini you may look in the official board list for supported boards and add their information accordingly. Either delete the obsolete <code>[env:...]</code> sections, or change your board as <code>default_envs = ...</code>.</p> <p>Default setup is for an ESP32-S3-DevKitC/M board</p> <p>The projects platformio.ini defaults for an ESP32-S3-DevKitC/M board by Espressif connected to the UART USB port. If you use an other board and the projects shows an undesired behavior it is likely that some parts do not match with pin definitions.</p>"},{"location":"gettingstarted/#build-upload-process","title":"Build &amp; Upload Process","text":"<p>After you've changed platformio.ini to suit your board you can upload the sample code to your board. This will download all ESP32 libraries and execute <code>node install</code> to install all node packages as well. Select your board's environment under the PlatformIO tab and hit <code>Upload and Monitor</code>.</p> <p></p> <p>The first build process will take a while. After a couple of minutes you can see the ESP32 outputting information on the terminal. Some of the python scripts might need to install additional packages. In that case the first build process will fail. Just run it a second time.</p> <p>Use several terminals in parallel</p> <p>VSCode allows you to have more then one terminal running at the same time. You can dedicate one terminal to the serial monitor, while having the development server running in an other terminal.</p>"},{"location":"gettingstarted/#setting-up-sveltekit","title":"Setting up SvelteKit","text":""},{"location":"gettingstarted/#setup-proxy-for-development","title":"Setup Proxy for Development","text":"<p>To ease the frontend development you can deploy the back end code on an ESP32 board and pass the websocket and REST API calls through the development server's proxy. The vite.config.ts file defines the location of the services which the development server will proxy. This is defined by the \"target\" property, which will need to be changed to the the IP address or hostname of the device running the firmware. Change this for both, \"http://\" and \"ws://\".</p> <pre><code>proxy: {\n    // Proxying REST: http://localhost:5173/rest/bar -&gt; http://192.168.1.83/rest/bar\n    '/rest': {\n    target: 'http://192.168.1.83',\n    changeOrigin: true,\n    },\n    // Proxying websockets ws://localhost:5173/ws -&gt; ws://192.168.1.83/ws\n    '/ws': {\n    target: 'ws://192.168.1.83',\n    changeOrigin: true,\n    ws: true,\n    },\n},\n</code></pre> <p>Tip</p> <p>You must restart the development server for changes of the proxy location to come into effect.</p>"},{"location":"gettingstarted/#development-server","title":"Development Server","text":"<p>The interface comes with Vite as a development server. It allows hot module reloading reflecting code changes to the front end instantly in your browser. Open a new terminal session and execute the following commands:</p> <pre><code>cd interface\nnpm run dev\n</code></pre> <p>Follow the link to access the front end in your browser.</p>"},{"location":"gettingstarted/#setup-material-for-mkdocs","title":"Setup Material for mkdocs","text":"<p>Material for MkDocs allows you to create great technical documentation pages just from markup. If you don't want to use it just delete the <code>.github</code> and <code>docs</code> folder, as well as <code>mkdocs.yaml</code>.</p> <p>Otherwise initiate the github CI pipeline by committing and pushing to your repository once. This triggers the automatic build. After a few minutes a new branch <code>gh-pages</code> containing the static website with your documentation should appear. To deploy it go to your github repository go under settings and complete the following steps. </p>"},{"location":"gettingstarted/#development-server_1","title":"Development Server","text":"<p>MkDocs comes with a build-in development server which supports hot reload as well. Open a new terminal session in VSCode and type</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"restfulapi/","title":"RESTful API","text":"<p>The back end exposes a number of API endpoints which are referenced in the table below.</p> Method Request URL Authentication POST JSON Body Info GET /rest/features <code>NONE_REQUIRED</code> none Tells the client which features of the UI should be use GET /rest/mqttStatus <code>IS_AUTHENTICATED</code> none Current MQTT connection status GET /rest/mqttSettings <code>IS_ADMIN</code> none Currently used MQTT settings POST /rest/mqttSettings <code>IS_ADMIN</code> <code>{\"enabled\":false,\"uri\":\"mqtt://192.168.1.12:1883\",\"username\":\"\",\"password\":\"\",\"client_id\":\"esp32-f412fa4495f8\",\"keep_alive\":120,\"clean_session\":true}</code> Update MQTT settings with new parameters GET /rest/ntpStatus <code>IS_AUTHENTICATED</code> none Current NTP connection status GET /rest/ntpSettings <code>IS_ADMIN</code> none Current NTP settings POST /rest/ntpSettings <code>IS_ADMIN</code> <code>{\"enabled\": true,\"server\": \"time.google.com\",\"tz_label\": \"Europe/London\",\"tz_format\": \"GMT0BST,M3.5.0/1,M10.5.0\"}</code> Update the NTP settings GET /rest/apStatus <code>IS_AUTHENTICATED</code> none Current AP status and client information GET /rest/apSettings <code>IS_ADMIN</code> none Current AP settings POST /rest/apSettings <code>IS_ADMIN</code> <code>{\"provision_mode\": 1,\"ssid\": \"ESP32-SvelteKit-e89f6d20372c\",\"password\": \"esp-sveltekit\",\"channel\": 1,\"ssid_hidden\": false,\"max_clients\": 4,\"local_ip\": \"4.3.2.1\",\"gateway_ip\": \"4.3.2.1\",\"subnet_mask\": \"255.255.255.0\"}</code> Update AP settings \ud83c\udf19 GET /rest/wifiStatus <code>IS_AUTHENTICATED</code> none Current status of the wifi client connection GET /rest/scanNetworks <code>IS_ADMIN</code> none Async Scan for Networks in Range GET /rest/listNetworks <code>IS_ADMIN</code> none List networks in range after successful scanning. Otherwise triggers scanning. GET /rest/wifiSettings <code>IS_ADMIN</code> none Current WiFi settings POST /rest/wifiSettings <code>IS_ADMIN</code> <code>{\"hostname\":\"esp32-f412fa4495f8\",\"connection_mode\":1,\"wifi_networks\":[{\"ssid\":\"YourSSID\",\"password\":\"YourPassword\",\"static_ip_config\":false}]}</code> Update WiFi settings and credentials GET /rest/systemStatus <code>IS_AUTHENTICATED</code> none Get system information about the ESP. POST /rest/restart <code>IS_ADMIN</code> none Restart the ESP32 POST /rest/factoryReset <code>IS_ADMIN</code> none Reset the ESP32 and all settings to their default values POST /rest/uploadFirmware <code>IS_ADMIN</code> none File upload of firmware.bin POST /rest/signIn <code>NONE_REQUIRED</code> <code>{\"password\": \"admin\",\"username\": \"admin\"}</code> Signs a user in and returns access token GET /rest/securitySettings <code>IS_ADMIN</code> none retrieves all user information and roles POST /rest/securitySettings <code>IS_ADMIN</code> <code>{\"jwt_secret\": \"734cb5bb-5597b722\", \"users\": [{\"username\": \"admin\", \"password\": \"admin\", \"admin\": true}, {\"username\": \"guest\", \"password\": \"guest\", \"admin\": false, }]}</code> retrieves all user information and roles GET /rest/verifyAuthorization <code>NONE_REQUIRED</code> none Verifies the content of the auth bearer token GET /rest/generateToken?username={username} <code>IS_ADMIN</code> <code>{\"token\": \"734cb5bb-5597b722\"}</code> Generates a new JWT token for the user from username POST /rest/sleep <code>IS_AUTHENTICATED</code> none Puts the device in deep sleep mode POST /rest/downloadUpdate <code>IS_ADMIN</code> <code>{\"download_url\": \"https://github.com/theelims/ESP32-sveltekit/releases/download/v0.1.0/firmware_esp32s3.bin\"}</code> Download link for OTA. This requires a valid SSL certificate and will follow redirects. GET /rest/coreDump <code>IS_AUTHENTICATED</code> Text Core dump of the last crash."},{"location":"statefulservice/","title":"Developing with the Framework","text":"<p>The back end is a set of REST endpoints hosted by a PsychicHttp instance. The 'lib/framework' directory contains the majority of the back end code. The framework contains a number of useful utility classes which you can use when extending it. The project also comes with a demo project to give you some help getting started.</p> <p>The framework's source is split up by feature, for example WiFiScanner.h implements the end points for scanning for available networks where as WiFiSettingsService.h handles configuring the WiFi settings and managing the WiFi connection.</p>"},{"location":"statefulservice/#initializing-the-framework","title":"Initializing the framework","text":"<p>The 'src/main.cpp' file constructs the web server and initializes the framework. You can add endpoints to the server here to support your IoT project. The main loop is also accessible so you can run your own code easily.</p> <p>The following code creates the web server and esp32sveltekit framework:</p> <pre><code>PsychicHttpServer server;\nESP32SvelteKit esp32sveltekit(&amp;server, 120);\n</code></pre> <p>ESP32SvelteKit is instantiated with a reference to the server and a number of HTTP endpoints. The underlying ESP-IDF HTTP Server statically allocates memory for each endpoint and needs to know how many there are. Best is to inspect your WWWData.h file for the number of Endpoints from SvelteKit (currently 60), the framework itself has 37 endpoints, and Lighstate Demo has 7 endpoints. Each <code>_server.on()</code> counts as an endpoint. Don't forget to add a couple of spare, just in case. Each HttpEndpoint adds 2 endpoints, if CORS is enabled it adds an other endpoint for the CORS preflight request.</p> <p>Now in the <code>setup()</code> function the initialization is performed:</p> <pre><code>void setup() {\n  // start serial and filesystem\n  Serial.begin(SERIAL_BAUD_RATE);\n\n  // start the framework and demo project\n  esp32sveltekit.begin();\n}\n</code></pre> <p><code>server.begin()</code> is called by ESP32-SvelteKit, as the start-up sequence is crucial.</p>"},{"location":"statefulservice/#stateful-service","title":"Stateful Service","text":"<p>The framework promotes a modular design and exposes features you may re-use to speed up the development of your project. Where possible it is recommended that you use the features the frameworks supplies. These are documented in this section and a comprehensive example is provided by the demo project.</p> <p>The following diagram visualizes how the framework's modular components fit together, each feature is described in detail below.</p> <p></p> <p>The StatefulService.h class is responsible for managing state. It has an API which allows other code to update or respond to updates in the state it manages. You can define a data class to hold state, then build a StatefulService class to manage it. After that you may attach HTTP endpoints, WebSockets or MQTT topics to the StatefulService instance to provide commonly required features.</p> <p>Here is a simple example of a state class and a StatefulService to manage it:</p> <pre><code>class LightState {\n public:\n  bool on = false;\n  uint8_t brightness = 255;\n};\n\nclass LightStateService : public StatefulService&lt;LightState&gt; {\n};\n</code></pre>"},{"location":"statefulservice/#update-handler","title":"Update Handler","text":"<p>You may listen for changes to state by registering an update handler callback. It is possible to remove an update handler later if required.</p> <pre><code>// register an update handler\nupdate_handler_id_t myUpdateHandler = lightStateService.addUpdateHandler(\n  [&amp;](const String&amp; originId) {\n    Serial.print(\"The light's state has been updated by: \");\n    Serial.println(originId);\n  }\n);\n\n// remove the update handler\nlightStateService.removeUpdateHandler(myUpdateHandler);\n</code></pre> <p>An \"originId\" is passed to the update handler which may be used to identify the origin of an update. The default origin values the framework provides are:</p> Origin Description http An update sent over REST (HttpEndpoint) mqtt An update sent over MQTT (MqttEndpoint) websocketserver:{clientId} An update sent over WebSocket (WebSocketServer)"},{"location":"statefulservice/#hook-handler","title":"Hook Handler","text":"<p>Sometimes if can be desired to hook into every update of an state, even if the StateUpdateResult is <code>StateUpdateResult::UNCHANGED</code> and the update handler isn't called. In such cases you can use the hook handler. Similarly it can be removed later.</p> <pre><code>// register an update handler\nhook_handler_id_t myHookHandler = lightStateService.addHookHandler(\n  [&amp;](const String&amp; originId, StateUpdateResult &amp;result) {\n    Serial.printf(\"The light's state has been updated by: %s with result %d\\n\", originId, result);\n  }\n);\n\n// remove the update handler\nlightStateService.removeHookHandler(myHookHandler);\n</code></pre>"},{"location":"statefulservice/#read-update-state","title":"Read &amp; Update State","text":"<p>StatefulService exposes a read function which you may use to safely read the state. This function takes care of protecting against parallel access to the state in multi-core environments such as the ESP32.</p> <pre><code>lightStateService.read([&amp;](LightState&amp; state) {\n  digitalWrite(LED_PIN, state.on ? HIGH : LOW); // apply the state update to the LED_PIN\n});\n</code></pre> <p>StatefulService also exposes an update function which allows the caller to update the state with a callback. This function automatically calls the registered update handlers if the state has been changed. The example below changes the state of the light (turns it on) using the arbitrary origin \"timer\" and returns the \"CHANGED\" state update result, indicating that a change was made:</p> <pre><code>lightStateService.update([&amp;](LightState&amp; state) {\n   if (state.on) {\n    return StateUpdateResult::UNCHANGED; // lights were already on, return UNCHANGED\n  }\n  state.on = true;  // turn on the lights\n  return StateUpdateResult::CHANGED; // notify StatefulService by returning CHANGED\n}, \"timer\");\n</code></pre> <p>There are three possible return values for an update function which are as follows:</p> Origin Description StateUpdateResult::CHANGED The update changed the state, propagation should take place if required StateUpdateResult::UNCHANGED The state was unchanged, propagation should not take place StateUpdateResult::ERROR There was an error updating the state, propagation should not take place"},{"location":"statefulservice/#json-serialization","title":"JSON Serialization","text":"<p>When reading or updating state from an external source (HTTP, WebSockets, or MQTT for example) the state must be marshalled into a serializable form (JSON). SettingsService provides two callback patterns which facilitate this internally:</p> Callback Signature Purpose JsonStateReader void read(T&amp; settings, JsonObject&amp; root) Reading the state object into a JsonObject JsonStateUpdater StateUpdateResult update(JsonObject&amp; root, T&amp; settings) Updating the state from a JsonObject, returning the appropriate StateUpdateResult <p>The static functions below can be used to facilitate the serialization/deserialization of the light state:</p> <pre><code>class LightState {\n public:\n  bool on = false;\n  uint8_t brightness = 255;\n\n  static void read(LightState&amp; state, JsonObject&amp; root) {\n    root[\"on\"] = state.on;\n    root[\"brightness\"] = state.brightness;\n  }\n\n  static StateUpdateResult update(JsonObject&amp; root, LightState&amp; state) {\n    state.on = root[\"on\"] | false;\n    state.brightness = root[\"brightness\"] | 255;\n    return StateUpdateResult::CHANGED;\n  }\n};\n</code></pre> <p>For convenience, the StatefulService class provides overloads of its <code>update</code> and <code>read</code> functions which utilize these functions.</p> <p>Read the state to a JsonObject using a serializer:</p> <pre><code>JsonObject jsonObject = jsonDocument.to&lt;JsonObject&gt;();\nlightStateService-&gt;read(jsonObject, LightState::read);\n</code></pre> <p>Update the state from a JsonObject using a deserializer:</p> <pre><code>JsonObject jsonObject = jsonDocument.as&lt;JsonObject&gt;();\nlightStateService-&gt;update(jsonObject, LightState::update, \"timer\");\n</code></pre>"},{"location":"statefulservice/#http-restful-endpoint","title":"HTTP RESTful Endpoint","text":"<p>The framework provides an HttpEndpoint.h class which may be used to register GET and POST handlers to read and update the state over HTTP. You may construct an HttpEndpoint as a part of the StatefulService or separately if you prefer.</p> <p>The code below demonstrates how to extend the LightStateService class to provide an endpoint:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(PsychicHttpServer* server, ESP32SvelteKit *sveltekit) :\n      _httpEndpoint(LightState::read, LightState::update, this, server, \"/rest/lightState\", sveltekit-&gt;getSecurityManager(),AuthenticationPredicates::IS_AUTHENTICATED) {\n  }\n\n  void begin(); {\n    _httpEndpoint.begin();\n  }\n\n private:\n  HttpEndpoint&lt;LightState&gt; _httpEndpoint;\n};\n</code></pre> <p>Endpoint security is provided by authentication predicates which are documented below. The SecurityManager and authentication predicate must be provided, even if no secure endpoint is required. The placeholder project shows how endpoints can be secured.</p> <p>To register the HTTP endpoints with the web server the function <code>_httpEndpoint.begin()</code> must be called in the custom StatefulService Class' own <code>void begin()</code> function.</p>"},{"location":"statefulservice/#file-system-persistence","title":"File System Persistence","text":"<p>FSPersistence.h allows you to save state to the filesystem. FSPersistence automatically writes changes to the file system when state is updated. This feature can be disabled by calling <code>disableUpdateHandler()</code> if manual control of persistence is required.</p> <p>The code below demonstrates how to extend the LightStateService class to provide persistence:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(ESP32SvelteKit *sveltekit) :\n      _fsPersistence(LightState::read, LightState::update, this, sveltekit-&gt;getFS(), \"/config/lightState.json\") {\n  }\n\n private:\n  FSPersistence&lt;LightState&gt; _fsPersistence;\n};\n</code></pre>"},{"location":"statefulservice/#event-socket-endpoint","title":"Event Socket Endpoint","text":"<p>EventEndpoint.h wraps the Event Socket into an endpoint compatible with a stateful service. The client may subscribe and unsubscribe to this event to receive updates or push updates to the ESP32. The current state is synchronized upon subscription.</p> <p>The code below demonstrates how to extend the LightStateService class to provide an WebSocket:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(ESP32SvelteKit *sveltekit) :\n      _eventEndpoint(LightState::read, LightState::update, this, sveltekit-&gt;getSocket(), \"led\") {}\n\n  void begin()\n  {\n    _eventEndpoint.begin();\n  }\n\n private:\n  EventEndpoint&lt;LightState&gt; _eventEndpoint;\n};\n</code></pre> <p>To register the event endpoint with the event socket the function <code>_eventEndpoint.begin()</code> must be called in the custom StatefulService Class' own <code>void begin()</code> function.</p> <p>Since all events run through one websocket connection it is not possible to use the securityManager to limit access to individual events. The security defaults to <code>AuthenticationPredicates::IS_AUTHENTICATED</code>.</p>"},{"location":"statefulservice/#websocket-server","title":"WebSocket Server","text":"<p>WebSocketServer.h allows you to read and update state over a WebSocket connection. WebSocketServer automatically pushes changes to all connected clients when state is updated.</p> <p>The code below demonstrates how to extend the LightStateService class to provide an WebSocket:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(PsychicHttpServer* server, ESP32SvelteKit *sveltekit) :\n      _webSocket(LightState::read, LightState::update, this, server, \"/ws/lightState\", sveltekit-&gt;getSecurityManager(), AuthenticationPredicates::IS_AUTHENTICATED), {\n  }\n\n  void begin() {\n    _webSocketServer.begin();\n  }\n\n private:\n  WebSocketServer&lt;LightState&gt; _webSocketServer;\n};\n</code></pre> <p>WebSocket security is provided by authentication predicates which are documented below. The SecurityManager and authentication predicate must be provided, even if no secure endpoint is required. The placeholder project shows how endpoints can be secured.</p> <p>To register the WS endpoint with the web server the function <code>_webSocketServer.begin()</code> must be called in the custom StatefulService Class' own <code>void begin()</code> function.</p>"},{"location":"statefulservice/#mqtt-client","title":"MQTT Client","text":"<p>The framework includes an MQTT client which can be configured via the UI. MQTT requirements will differ from project to project so the framework exposes the client for you to use as you see fit. The framework does however provide a utility to interface StatefulService to a pair of pub/sub (state/set) topics. This utility can be used to synchronize state with software such as Home Assistant.</p> <p>MqttEndpoint.h allows you to publish and subscribe to synchronize state over a pair of MQTT topics. MqttEndpoint automatically pushes changes to the \"pub\" topic and reads updates from the \"sub\" topic.</p> <p>The code below demonstrates how to extend the LightStateService class to interface with MQTT:</p> <pre><code>class LightStateService : public StatefulService&lt;LightState&gt; {\n public:\n  LightStateService(ESP32SvelteKit *sveltekit) :\n      _mqttEndpoint(LightState::read,\n                  LightState::update,\n                  this,\n                  sveltekit-&gt;getMqttClient(),\n                  \"homeassistant/light/my_light/set\",\n                  \"homeassistant/light/my_light/state\") {\n  }\n\n private:\n  MqttEndpoint&lt;LightState&gt; _mqttEndpoint;\n};\n</code></pre> <p>You can re-configure the pub/sub topics at runtime as required:</p> <pre><code>_mqttEndpoint.configureBroker(\"homeassistant/light/desk_lamp/set\", \"homeassistant/light/desk_lamp/state\");\n</code></pre> <p>The demo project allows the user to modify the MQTT topics via the UI so they can be changed without re-flashing the firmware.</p>"},{"location":"statefulservice/#event-socket","title":"Event Socket","text":"<p>Beside RESTful HTTP Endpoints the Event Socket System provides a convenient communication path between the client and the ESP32. It uses a single WebSocket connection to synchronize state and to push realtime data to the client. The client needs to subscribe to the topics he is interested. Only clients who have an active subscription will receive data. Every authenticated client may make use of this system as the security settings are set to <code>AuthenticationPredicates::IS_AUTHENTICATED</code>.</p>"},{"location":"statefulservice/#message-format","title":"Message Format","text":"<p>The event messages exchanged between the ESP32 and its clients consists of an \"event\" head and the \"data\" payload. For the LightState example a message looks like this in JSON representation:</p> <pre><code>{\n  \"event\": \"led\",\n  \"data\": {\n    \"led_on\": true\n  }\n}\n</code></pre> <p>To save on bandwidth the event message is encoded as binary MessagePack instead of a JSON.</p> <p>To subscribe the client has to send the following message (as MessagePack):</p> <pre><code>{\n  \"event\": \"subscribe\",\n  \"data\": \"analytics\"\n}\n</code></pre>"},{"location":"statefulservice/#emit-an-event","title":"Emit an Event","text":"<p>The Event Socket provides an <code>emitEvent()</code> function to push data to all subscribed clients. This is used by various esp32sveltekit classes to push real time data to the client. First an event must be registered with the Event Socket by calling <code>_socket.registerEvent(\"CustomEvent\");</code>. Only then clients may subscribe to this custom event and you're entitled to emit event data:</p> <pre><code>void emitEvent(String event, JsonObject &amp;jsonObject, const char *originId = \"\", bool onlyToSameOrigin = false);\n</code></pre> <p>The latter function allowing a selection of the recipient. If <code>onlyToSameOrigin = false</code> the payload is distributed to all subscribed clients, except the <code>originId</code>. If <code>onlyToSameOrigin = true</code> only the client with <code>originId</code> will receive the payload. This is used by the EventEndpoint to sync the initial state when a new client subscribes.</p>"},{"location":"statefulservice/#receive-an-event","title":"Receive an Event","text":"<p>A callback or lambda function can be registered to receive an ArduinoJSON object and the originId of the client sending the data:</p> <pre><code>_socket.onEvent(\"CostumEvent\",[&amp;](JsonObject &amp;root, int originId)\n{\n  bool ledState = root[\"led_on\"];\n});\n</code></pre>"},{"location":"statefulservice/#get-notified-on-subscriptions","title":"Get Notified on Subscriptions","text":"<p>Similarly a callback or lambda function may be registered to get notified when a client subscribes to an event:</p> <pre><code>_socket.onSubscribe(\"CostumEvent\",[&amp;](const String &amp;originId)\n{\n  Serial.println(\"New Client subscribed: \" + originId);\n});\n</code></pre> <p>The boolean parameter provided will always be <code>true</code>.</p>"},{"location":"statefulservice/#push-notifications-to-all-clients","title":"Push Notifications to All Clients","text":"<p>It is possibly to send push notifications to all clients by using the Event Socket. These will be displayed as toasts an the client side. Either directly call</p> <pre><code>esp32sveltekit.getNotificationService()-&gt;pushNotification(\"Pushed a message!\", PUSHINFO);\n</code></pre> <p>or keep a local pointer to the <code>EventSocket</code> instance. It is possible to send <code>PUSHINFO</code>, <code>PUSHWARNING</code>, <code>PUSHERROR</code> and <code>PUSHSUCCESS</code> events to all clients.</p>"},{"location":"statefulservice/#security-features","title":"Security features","text":"<p>The framework has security features to prevent unauthorized use of the device. This is driven by SecurityManager.h.</p> <p>On successful authentication, the /rest/signIn endpoint issues a JSON Web Token (JWT) which is then sent using Bearer Authentication. For this add an <code>Authorization</code>-Header to the request with the Content <code>Bearer {JWT-Secret}</code>. The framework come with built-in predicates for verifying a users access privileges. The built in AuthenticationPredicates can be found in SecurityManager.h and are as follows:</p> Predicate Description NONE_REQUIRED No authentication is required. IS_AUTHENTICATED Any authenticated principal is permitted. IS_ADMIN The authenticated principal must be an admin. <p>You can use the security manager to wrap any request handler function with an authentication predicate:</p> <pre><code>server-&gt;on(\"/rest/someService\", HTTP_GET,\n  _securityManager-&gt;wrapRequest(std::bind(&amp;SomeService::someService, this, std::placeholders::_1), AuthenticationPredicates::IS_AUTHENTICATED)\n);\n</code></pre> <p>In case of a websocket connection the JWT token is supplied as a search parameter in the URL when establishing the connection:</p> <pre><code>/ws/lightState?access_token={JWT Token}\n</code></pre>"},{"location":"statefulservice/#placeholder-substitution","title":"Placeholder substitution","text":"<p>Various settings support placeholder substitution, indicated by comments in factory_settings.ini. This can be particularly useful where settings need to be unique, such as the Access Point SSID or MQTT client id. Strings must be properly escaped in the ini-file. The following placeholders are supported:</p> Placeholder Substituted value #{platform} The microcontroller platform, e.g. \"esp32\" or \"esp32c3\" #{unique_id} A unique identifier derived from the MAC address, e.g. \"0b0a859d6816\" #{random} A random number encoded as a hex string, e.g. \"55722f94\" <p>You may use SettingValue::format in your own code if you require the use of these placeholders. This is demonstrated in the demo project:</p> <pre><code>  static StateUpdateResult update(JsonObject&amp; root, LightMqttSettings&amp; settings) {\n    settings.mqttPath = root[\"mqtt_path\"] | SettingValue::format(\"homeassistant/light/#{unique_id}\");\n    settings.name = root[\"name\"] | SettingValue::format(\"light-#{unique_id}\");\n    settings.uniqueId = root[\"unique_id\"] | SettingValue::format(\"light-#{unique_id}\");\n    return StateUpdateResult::CHANGED;\n  }\n</code></pre>"},{"location":"statefulservice/#accessing-settings-and-services","title":"Accessing settings and services","text":"<p>The framework supplies access to various features via getter functions:</p> SettingsService Description getFS() The filesystem used by the framework getSecurityManager() The security manager - detailed above getSecuritySettingsService() Configures the users and other security settings getWiFiSettingsService() Configures and manages the WiFi network connection getAPSettingsService() Configures and manages the Access Point getNTPSettingsService() Configures and manages the network time getMqttSettingsService() Configures and manages the MQTT connection getMqttClient() Provides direct access to the MQTT client instance getNotificationEvents() Lets you send push notifications to all clients getSleepService() Send the ESP32 into deep sleep getBatteryService() Update battery information on the client <p>The core features use the StatefulService.h class and therefore you can change settings or observe changes to settings through the read/update API.</p> <p>Inspect the current WiFi settings:</p> <pre><code>esp32sveltekit.getWiFiSettingsService()-&gt;read([&amp;](WiFiSettings&amp; wifiSettings) {\n  Serial.print(\"The ssid is:\");\n  Serial.println(wifiSettings.ssid);\n});\n</code></pre> <p>Configure the WiFi SSID and password manually:</p> <pre><code>esp32sveltekit.getWiFiSettingsService()-&gt;update([&amp;](WiFiSettings&amp; wifiSettings) {\n  wifiSettings.ssid = \"MyNetworkSSID\";\n  wifiSettings.password = \"MySuperSecretPassword\";\n  return StateUpdateResult::CHANGED;\n}, \"myapp\");\n</code></pre> <p>Observe changes to the WiFiSettings:</p> <pre><code>esp32sveltekit.getWiFiSettingsService()-&gt;addUpdateHandler(\n  [&amp;](const String&amp; originId) {\n    Serial.println(\"The WiFi Settings were updated!\");\n  }\n);\n</code></pre>"},{"location":"statefulservice/#other-functions-provided","title":"Other functions provided","text":""},{"location":"statefulservice/#mdns-instance-name","title":"MDNS Instance Name","text":"<p>ESP32 SvelteKit uses mDNS / Bonjour to advertise its services into the local network. You can set the mDNS instance name property by calling</p> <pre><code>esp32sveltekit.setMDNSAppName(\"ESP32 SvelteKit Demo App\");\n</code></pre> <p>making the entry a little bit more verbose. This must be called before <code>esp32sveltekit.begin();</code>. If you want to advertise further services just include <code>#include &lt;ESPmNDS.h&gt;</code> and use <code>MDNS.addService()</code> regularly.</p>"},{"location":"statefulservice/#use-esp32-sveltekit-loop-function","title":"Use ESP32-SvelteKit loop() Function","text":"<p>Under some circumstances custom services might want to do something periodically. One solution would be to use a dedicated task or RTOS timer for this. Or you can leverage the ESP32-SvelteKit loop-function and have it executed as a callback every 20ms.</p> <pre><code>esp32sveltekit.addLoopFunction(callback)\n</code></pre>"},{"location":"statefulservice/#factory-reset","title":"Factory Reset","text":"<p>A factory reset can not only be evoked from the API, but also by calling</p> <pre><code>esp32sveltekit.factoryReset();\n</code></pre> <p>from your code. This will erase the complete settings folder, wiping out all settings. This can be a last fall back mode if somebody has forgotten his credentials.</p>"},{"location":"statefulservice/#recovery-mode","title":"Recovery Mode","text":"<p>There is also a recovery mode present which will force the creation of an access point. By calling</p> <pre><code>esp32sveltekit.recoveryMode();\n</code></pre> <p>will force a start of the AP regardless of the AP settings. It will not change the the AP settings. To exit the recovery mode restart the device or change the AP settings in the UI.</p>"},{"location":"statefulservice/#power-down-with-deep-sleep","title":"Power Down with Deep Sleep","text":"<p>This API service can place the ESP32 in the lowest power deep sleep mode consuming only a few \u00b5A. It uses the EXT1 wakeup source, so the ESP32 can be woken up with a button or from a peripherals interrupt. Consult the ESP-IDF Api Reference which GPIOs can be used for this. The RTC will also be powered down, so an external pull-up or pull-down resistor is required. It is not possible to persist variable state through the deep sleep. To optimize the deep sleep power consumption it is advisable to use the callback function to put pins with external pull-up's or pull-down's in a special isolated state to prevent current leakage. Please consult the ESP-IDF Api Reference for this.</p> <p>The settings wakeup pin definition and the signal polarity need to be defined in factory_settings.ini:</p> <pre><code>; Deep Sleep Configuration\n-D WAKEUP_PIN_NUMBER=38 ; pin number to wake up the ESP\n-D WAKEUP_SIGNAL=0 ; 1 for wakeup on HIGH, 0 for wakeup on LOW\n</code></pre> <p>In addition it is possible to change this as well at runtime by calling:</p> <pre><code>esp32sveltekit.getSleepService()-&gt;setWakeUpPin(int pin, bool level, pinTermination termination = pinTermination::FLOATING);\n</code></pre> <p>With this function it is also possible to configure the internal pull-up or pull-down resistor for this RTC pin. Albeit this might increase the deep sleep current slightly.</p> <p>A callback function can be attached and triggers when the ESP32 is requested to go into deep sleep. This allows you to safely deal with the power down event. Like persisting software state by writing to the flash, tiding up or notify a remote server about the immanent disappearance.</p> <pre><code>esp32sveltekit.getSleepService()-&gt;attachOnSleepCallback();\n</code></pre> <p>Also the code can initiate the power down deep sleep sequence by calling:</p> <pre><code>esp32sveltekit.getSleepService()-&gt;sleepNow();\n</code></pre>"},{"location":"statefulservice/#battery-state-of-charge","title":"Battery State of Charge","text":"<p>A small helper class let's you update the battery icon in the status bar. This is useful if you have a battery operated IoT device. It must be enabled in features.ini. It uses the Event Socket and exposes two functions that can be used to update the clients.</p> <pre><code>esp32sveltekit.getBatteryService()-&gt;updateSOC(float stateOfCharge); // update state of charge in percent (0 - 100%)\nesp32sveltekit.getBatteryService()-&gt;setCharging(boolean isCharging); // notify the client that the device is charging\n</code></pre> <p> For devices where battery voltage is exposed on a pin you can measure the voltage and updateSOC by specifying this in platformio.ini:</p> <pre><code>    -D BATTERY_PIN=35 ; Used if FT_BATTERY=1\n    -D BATTERY_MV=4200 ; Used if FT_BATTERY=1\n</code></pre> <p>For other devices (like I2C fuel gauge IC's) you have to implement your own measure code.</p>"},{"location":"statefulservice/#esp32-sveltekit-connection-status","title":"ESP32-SvelteKit Connection Status","text":"<p>Especially for a cases like a colored status LED it can be useful to have a quick indication of the connection status. By calling:</p> <pre><code>ConnectionStatus status = esp32sveltekit.getConnectionStatus();\n</code></pre> <p>the current connection status can be accessed. The following stats are available:</p> Status Description OFFLINE Device is completely offline AP Access Point is available, but no client is connected AP_CONNECTED Access Point is used and at least 1 client is connected STA Device connected to a WiFi Station STA_CONNECTED Device connected to a WiFi Station and at least 1 client is connected STA_MQTT Device connected to a WiFi Station and the device is connected to a MQTT server"},{"location":"statefulservice/#custom-features","title":"Custom Features","text":"<p>You may use the compile time feature service also to enable or disable custom features at runtime and thus control the frontend. A custom feature can only be added during initializing the ESP32 and ESP32-SvelteKit. The frontend queries the features only when first loading the page. Thus the frontend must be refreshed for the changes to become effective.</p> <pre><code>esp32sveltekit.getFeatureService()-&gt;addFeature(\"custom_feature\", true); // or false to disable it\n</code></pre>"},{"location":"statefulservice/#ota-firmware-updates","title":"OTA Firmware Updates","text":"<p>ESP32-SvelteKit offers two different ways to roll out firmware updates to field devices. If the frontend should be updated as well it is necessary to embed it into the firmware binary by activating <code>-D EMBED_WWW</code>.</p>"},{"location":"statefulservice/#firmware-upload","title":"Firmware Upload","text":"<p>Enabling <code>FT_UPLOAD_FIRMWARE=1</code> in features.ini creates a REST endpoint that one can post a firmware binary to. The frontend has a file drop zone to upload a new firmware binary from the browser.</p>"},{"location":"statefulservice/#firmware-download-from-update-server","title":"Firmware Download from Update Server","text":"<p>By enabling <code>FT_DOWNLOAD_FIRMWARE=1</code> in features.ini one can POST a link to a firmware binary which is downloaded for the OTA process. This feature requires SSL and is thus dependent on <code>FT_NTP=1</code>. The Frontend contains an implementation which uses GitHub's Releases section as the update server. By specifying a firmware version in platformio.ini one can make use of semantic versioning to determine the correct firmware:</p> <pre><code>    -D BUILD_TARGET=\"$PIOENV\"\n    -D APP_NAME=\\\"ESP32-Sveltekit\\\" ; Must only contain characters from [a-zA-Z0-9-_] as this is converted into a filename\n    -D APP_VERSION=\\\"0.5.6.1\\\" ; semver compatible version string\n</code></pre> <p>A build script copies the firmware binary files for all build environment to <code>build/firmware</code>. It renames them into <code>{APP_NAME}_{$PIOENV}_{APP_VERSION}.bin</code>. It also creates a MD5 checksum file for verification during the OTA process. These files can be used as attachment on the GitHub release pages.</p> <p>Info</p> <p>This feature could be unstable on single-core members of the ESP32 family.</p>"},{"location":"statefulservice/#custom-update-server","title":"Custom Update Server","text":"<p>If Github is not desired as the update server this can be easily modified to any other custom server. The REST API will accept any valid HTTPS-Link. However, SSL is mandatory and may require a different Root CA Certificate then Github to validate correctly. Follow the instructions here how to change the SSL CA Certificate.</p> <p>If you use a custom update server you must also adapt the frontend code to suit your needs.</p>"},{"location":"stores/","title":"Stores","text":""},{"location":"stores/#user","title":"User","text":"<p>The user store holds the current users credentials, if the security features are enabled. Just import it as you would use with any svelte store:</p> <pre><code>import { user } from \"$lib/stores/user\";\n</code></pre> <p>You can subscribe to it like to any other store with <code>$user</code> and it has the following properties:</p> Property Type Description <code>$user.bearer_token</code> <code>String</code> The JWT token to authorize a user at the back end <code>$user.username</code> <code>String</code> Username of the current user <code>$user.admin</code> <code>Boolean</code> <code>true</code> if the current user has admin privileges <p>In addition to the properties it provides two methods for initializing the user credentials and to invalidate them. <code>user.init()</code> takes a valid JWT toke as an argument and extracts the user privileges and username from it. <code>user.invalidate()</code> invalidates the user credentials and redirects to the login pages</p> <p>User credentials are stored in the browsers local storage</p> <p>The user credentials including the JWT token are stored in the browsers local storage. Any javascript executed on the browser can access this making it extremely vulnerable to XSS attacks. Also the HTTP connection between ESP32 and front end is not encrypted making it possible for everyone to read the JWT token in the same network. Fixing these severe security issues is on the todo list for upcoming releases.</p>"},{"location":"stores/#event-socket","title":"Event Socket","text":"<p>The Event Socket System is conveniently provided as a Svelte store. Import the store, subscribe to the data interested with <code>socket.on</code>. To unsubscribe simply call <code>socket.off</code>. Data can be sent to the ESP32 by calling <code>socket.sendEvent</code></p> <pre><code>import { socket } from \"$lib/stores/socket\";\n\nlet lightState: LightState = { led_on: false };\n\nonMount(() =&gt; {\n  socket.on&lt;LightState&gt;(\"led\", (data) =&gt; {\n    lightState = data;\n  });\n});\n\nonDestroy(() =&gt; socket.off(\"led\"));\n\nsocket.sendEvent(\"led\", lightState);\n</code></pre> <p>Subscribing to an invalid event will only create a warning in the ESP_LOG on the serial console of the ESP32.</p>"},{"location":"stores/#telemetry","title":"Telemetry","text":"<p>The telemetry store can be used to update telemetry data like RSSI via the Event Socket system.</p> <pre><code>import { telemetry } from \"$lib/stores/telemetry\";\n</code></pre> <p>It exposes the following properties you can subscribe to:</p> Property Type Description <code>$telemetry.rssi.rssi</code> <code>Number</code> The RSSI signal strength of the WiFi in dBm <code>$telemetry.rssi.ssid</code> <code>String</code> Name of the connected WiFi station <code>$telemetry.rssi.connected</code> <code>Boolean</code> Connection status of the WiFi <code>$telemetry.battery.soc</code> <code>Number</code> Battery state of charge <code>$telemetry.battery.charging</code> <code>Boolean</code> Is battery connected to charger <code>$telemetry.download_ota.status</code> <code>String</code> Status of OTA <code>$telemetry.download_ota.progress</code> <code>Number</code> Progress of OTA <code>$telemetry.download_ota.error</code> <code>String</code> Error Message of OTA"},{"location":"stores/#analytics","title":"Analytics","text":"<p>The analytics store holds a log of heap and other debug information via the Event Socket system.</p> <pre><code>import { analytics } from \"$lib/stores/analytics\";\n</code></pre> <p>It exposes an array of the following properties you can subscribe to:</p> Property Type Description <code>$analytics.uptime</code> <code>Number</code> Uptime of the chip in seconds since last reset <code>$analytics.free_heap</code> <code>Number</code> Current free heap <code>$analytics.min_free_heap</code> <code>Number</code> Minimum free heap that has been <code>$analytics.max_alloc_heap</code> <code>Number</code> Biggest continues free chunk of heap <code>$analytics.fs_used</code> <code>Number</code> Bytes used on the file system <code>$analytics.fs_total</code> <code>Number</code> Total bytes of the file system <code>$analytics.core_temp</code> <code>Number</code> Core temperature (on some chips) <p>By default there is one data point every 2 seconds. It holds 1000 data points worth roughly 33 Minutes of data.</p>"},{"location":"structure/","title":"Customizing the Front End","text":"<p>The actual code for the front end is located under interface/src/ and divided into the \"routes\" folder and a \"lib\" folder for assets, stores and components.</p> Resource Description routes/ Root of the routing system routes/connections/ Setting and status pages for MQTT, NTP, etc. routes/demo/ The lightstate demo routes/system/ Status page for ESP32 and OTA settings routes/user/ Edit and add users and change passwords routes/wifi/ Status and settings for WiFi station and AP lib/ Library folder for stores, components and assets lib/assets/ Assets like pictures lib/components/ Reusable components like modals, password input or collapsible lib/stores Svelte stores for common access to data"},{"location":"structure/#features","title":"Features","text":"<p>The back end provides a JSON which features of the back end are enabled by the feature selection. It is fetched with the page load and made available in the <code>pages</code>-store and can be accessed on any site with <code>page.data.features</code>. It is used to hide any disabled setting element.</p>"},{"location":"structure/#delete-demo-project","title":"Delete <code>demo/</code> Project","text":"<p>The light state demo project is included by default to demonstrate the use of the backend and front end. It demonstrates the use of the MQTT-API, websocket API and REST API to switch on the build in LED of the board. routes/connections/mqtt/MQTTConfig.svelte is also part of the 'demo/' Project. You can reuse this to set your own MQTT topics, or delete it. Do not forget to adjust <code>+page.svelte</code> as well. Use it as an example how to create your own custom API and access it from the front end. It can be deleted safely after it has been removed from the menu as well.</p>"},{"location":"structure/#create-your-root-pagesvelte","title":"Create your root <code>+page.svelte</code>","text":"<p>The root page of the front end is located under routes/+page.svelte. This should be the central place of your app and can be accessed at any time by pressing the logo and app name in the side menu. Just override it to suit your needs.</p>"},{"location":"structure/#customize-the-main-menu","title":"Customize the Main Menu","text":"<p>The main menu is located in routes/menu.svelte as a svelte component and defines the main menu including a menu footer.</p>"},{"location":"structure/#menu-footer","title":"Menu Footer","text":"<p>The main menu comes with a small footer to add your copyright notice plus links to github and your discord server where users can find help. The <code>active</code>-flag is used to disable an element in the UI. Most of these global parameters are set in the routes/+layout.ts.</p> <pre><code>const discord = { href: \".\", active: false };\n</code></pre>"},{"location":"structure/#menu-structure","title":"Menu Structure","text":"<p>The menu consists of an array of menu items. These are defined as follows:</p> <pre><code>{\n    title: 'Demo App',\n    icon: Control,\n    href: '/demo',\n    feature: page.data.features.project,\n},\n</code></pre> <ul> <li>Where <code>title</code> refers to the page title. It must be identical to <code>page.data.title</code> as defined in the <code>+page.ts</code> in any of your routes. If they do not match the corresponding menu item is not highlighted on first page load or a page refresh. </li> </ul> <p></p> <p>Info</p> <p>Note \ud83c\udf19: In MoonBase matching is not done on title but on href, which is not compared with page.ts title but with page.url.pathname + page.url.search (see Menu.svelte)</p> <p>A minimum <code>+page.ts</code> looks like this:</p> <pre><code>import type { PageLoad } from \"./$types\";\n\nexport const load = (async ({ fetch }) =&gt; {\n  return {\n    title: \"Demo App\",\n  };\n}) satisfies PageLoad;\n</code></pre> <ul> <li><code>icon</code> must be an icon component giving the menu items icon.</li> <li><code>href</code> is the link to the route the menu item refers to.</li> <li><code>feature</code> takes a bool and should be set to <code>true</code>. It is used by the feature selector to hide a menu entry of it is not present on the back end.</li> </ul>"},{"location":"structure/#advanced-customizations","title":"Advanced Customizations","text":"<p>On the root level there are two more files which you can customize to your needs.</p>"},{"location":"structure/#login-page","title":"Login Page","text":"<p><code>login.svelte</code> is a component showing the login screen, when the security features are enabled. By default it shows the app's logo and the login prompt. Change it as you need it.</p>"},{"location":"structure/#status-bar","title":"Status Bar","text":"<p><code>statusbar.svelte</code> contains the top menu bar which you can customize to show state information about your app and IoT device. By default it shows the active menu title and the hamburger icon on small screens.</p>"},{"location":"structure/#github-firmware-update","title":"Github Firmware Update","text":"<p>If the feature <code>FT_DOWNLOAD_FIRMWARE</code> is enabled, ESP32 SvelteKit pulls the Github Release section through the Github API for firmware updates once per hour. Also the firmware update menu shows all available firmware releases allowing the user to up- and downgrade has they please. If you're using the Github releases section you must first tell the frontend your correct path to your github repository as described here.</p> <p>Also you must make use of couple build flags in platformio.ini:</p> <pre><code>    -D BUILD_TARGET=\\\"$PIOENV\\\"\n    -D APP_NAME=\\\"ESP32-Sveltekit\\\" ; Must only contain characters from [a-zA-Z0-9-_] as this is converted into a filename\n    -D APP_VERSION=\\\"0.5.6.1\\\" ; semver compatible version string\n</code></pre> <p>Out of these flags the rename_fw.py script will copy and rename the firmware binary to <code>/build/firmware/{APP_NAME}_{$PIOENV}_{APP_VERSION}.bin</code>. In addition it will also create a corresponding MD5 checksum file. These files are ready to be uploaded to the Github release page without any further changes. The frontend searches for the firmware binary which matches the build environment and uses this as the update link. This allows you to serve different build targets (e.g. different boards) from the same release page.</p>"},{"location":"structure/#custom-update-server","title":"Custom Update Server","text":"<p>The frontend and backend code can be easily adjusted to suit a custom update server. For the backend the changes are described here. On the frontend only two files must be adapted and changed to switch to a custom update server: /lib/components/UpdateIndicator.svelte and /routes/system/update/GithubFirmwareManager.svelte.</p> <p>Info</p> <p>The update server must provide the firmware download through SSL encryption.</p>"},{"location":"sveltekit/","title":"Getting Started with SvelteKit","text":"<p>SvelteKits unique approach makes it perfect suitable for constraint server. It builds very small files shipping only the minimum required amount of java script. This keeps the memory footprint low so that rich applications can be build with just the 4MB flash of many ESP32 chips.</p> <p>However, since SvelteKit is designed with server-side rendering first, there are some catches and pitfalls one must avoid. Especially as nearly all tutorials found on SvelteKit heavily make use of the combined front and back end features.</p>"},{"location":"sveltekit/#limitations-of-adapter-static","title":"Limitations of <code>adapter-static</code>","text":"<p>To build a website that can be served from an ESP32 <code>adapter-static</code> is used. This means no server functions can be used. The front end is build as a Single-Page Application (SPA) instead. However, SvelteKit will pre-render sites at build time, even if SSR and pre-rendering are disabled. This leads to some restrictions that must be taken into consideration:</p> <ul> <li> <p>You can't use any server-side logic like <code>+page.server.ts</code>, <code>+layout.server.ts</code> or <code>+server.ts</code> files in your project.</p> </li> <li> <p>The load function in <code>+page.ts</code> gets executed on the server and the client. If you try to access browser resources in the load function this will fail. Use a more traditional way like fetching the data in the <code>+page.svelte</code> with the <code>onMount(() =&gt; {})</code> callback.</p> </li> </ul>"},{"location":"sveltekit/#customizing-and-theming","title":"Customizing and Theming","text":""},{"location":"sveltekit/#changing-the-app-name","title":"Changing the App Name","text":"<p>+layout.ts bundles a few globally customizable properties like github repository, app name and copyright notice:</p> <pre><code>export const load = (async () =&gt; {\n    const result = await fetch('/rest/features');\n    const item = await result.json();\n    return {\n        features: item,\n        title: 'ESP32-SvelteKit',\n        github: 'theelims/ESP32-sveltekit',\n        copyright: '2024 theelims',\n        appName: 'ESP32 SvelteKit'\n    };\n}) satisfies LayoutLoad;\n</code></pre> <p>In menu.svelte there is additionally the possibility to add a discord invite, which is disabled by default.</p> <pre><code>const discord = { href: \".\", active: false };\n</code></pre> <p>There is also a manifest file which contains the app name to use when adding the app to a mobile device, so you may wish to also edit interface/static/manifest.json:</p> <pre><code>{\n  \"name\": \"ESP32 SvelteKit\",\n  \"icons\": [\n    {\n      \"src\": \"/favicon.png\",\n      \"sizes\": \"48x48 72x72 96x96 128x128 256x256\"\n    }\n  ],\n  \"start_url\": \"/\",\n  \"display\": \"fullscreen\",\n  \"orientation\": \"any\"\n}\n</code></pre>"},{"location":"sveltekit/#changing-the-app-icon-and-favicon","title":"Changing the App Icon and Favicon","text":"<p>You can replace the apps favicon which is located at interface/static/favicon.png with one of your preference. A 256 x 256 PNG is recommended for best compatibility.</p> <p>Also the Svelte Logo can be replaced with your own. It is located under interface/src/lib/assets/logo.png.</p>"},{"location":"sveltekit/#daisy-ui-themes","title":"Daisy UI Themes","text":"<p>The overall theme of the front end is defined by DaisyUI and can be easily changed according to their documentation. Either by selecting one of the standard themes of DaisyUI, or creating your own. By default the <code>corporate</code> and <code>business</code> for dark are defined in app.css:</p> <pre><code>@plugin \"daisyui\" {\n    themes: corporate --default, business --prefersdark;\n}\n</code></pre>"},{"location":"sveltekit/#opinionated-use-of-shadows","title":"Opinionated use of Shadows","text":"<p>The front end makes some use of colored shadows with the <code>shadow-primary</code> and <code>shadow-secondary</code> DaisyUI classes. Just use the search and replace function to change this to a more neutral look, if you find the color too much.</p>"},{"location":"sveltekit/#color-scheme-helper","title":"Color Scheme Helper","text":"<p>Some JS modules do not accept DaisyUI/TailwindCSS color class names. A small helper function can be imported and used to convert any CSS variable name for a DaisyUI color into OKCHL. That way modules like e.g. Charts.js can be styled in the current color scheme in a responsive manner.</p> <pre><code>import { daisyColor } from \"$lib/DaisyUiHelper\";\n\nborderColor: daisyColor('--color-primary'),\nbackgroundColor: daisyColor('--color-primary', 50),\n</code></pre>"},{"location":"sveltekit/#ts-types-definition","title":"TS Types Definition","text":"<p>All types used throughout the front end are exported from models.ts. It is a convenient location to add your custom types once you expand the front end.</p>"},{"location":"connections/mqtt/","title":"MQTT","text":""},{"location":"connections/mqtt/#functional","title":"Functional","text":""},{"location":"connections/mqtt/#technical","title":"Technical","text":""},{"location":"connections/mqtt/#server","title":"Server","text":"<p>SystemStatus.h and SystemStatus.cpp</p>"},{"location":"connections/mqtt/#ui","title":"UI","text":"<p>SystemStatus.svelte</p>"},{"location":"connections/ntp/","title":"NTP","text":""},{"location":"connections/ntp/#functional","title":"Functional","text":""},{"location":"connections/ntp/#technical","title":"Technical","text":""},{"location":"connections/ntp/#server","title":"Server","text":"<p>SystemStatus.h and SystemStatus.cpp</p>"},{"location":"connections/ntp/#ui","title":"UI","text":"<p>SystemStatus.svelte</p>"},{"location":"general/customizingsveltekit/","title":"Customizing sveltekit","text":""},{"location":"general/customizingsveltekit/#customize-ui-and-app-specific","title":"Customize UI and app specific","text":"<p>This is a checklist, More info on most of the items can be found in the ESP32-Sveltekit specific documentation ESP32 SvelteKit, Build Tools, Front end and Back End</p> <ul> <li> <p>{custom} = MoonLight or name of a forked repo</p> </li> <li> <p>docs/media/</p> <ul> <li>add {custom}-logo.png (used in mkdocs.yml)</li> <li>replace favicon.png</li> </ul> </li> <li>factory_settings.ini<ul> <li>FACTORY_AP_SSID=\\\"{custom}-#{unique_id}\\\"</li> <li>FACTORY_AP_PASSWORD=\\\"\\\" (recommendation)</li> <li>FACTORY_NTP_TIME_ZONE_LABEL=\\\"Europe/Amsterdam\\\"</li> </ul> </li> <li>package.json<ul> <li>name = \"{custom}\"</li> <li>version: \"0.5.6\",</li> </ul> </li> <li>intrerface/source/lib/assets/logo.png<ul> <li>replace logo</li> </ul> </li> <li>interface/source/routes/+layout.ts<ul> <li>title: '{custom}'</li> <li>github:</li> <li>copyright</li> <li>appname: '{custom}'</li> </ul> </li> <li>interface/source/routes/+page.svelte<ul> <li>Welcome to {custom}</li> <li>Intro message</li> <li>href=\"/\" </li> <li>Start {custom}</li> </ul> </li> <li>interface/source/routes/menu.svelte<ul> <li>const discord = { href: 'https://discord.gg/TC8NSUSCdV', active: true };</li> </ul> </li> <li>interface/static/manifest.json<ul> <li>name: \"{custom}\"</li> </ul> </li> <li>interface/static/favicon.png<ul> <li>replace favicon.png</li> </ul> </li> <li>lib/framework/APSettingsService.h<ul> <li>FACTORY_AP_SSID \"{custom}-#{unique_id}\"</li> <li>FACTORY_AP_PASSWORD \"\"</li> </ul> </li> <li>mkdocs.yml<ul> <li>site_name: {custom}</li> <li>nav: {custom}</li> <li>repo_name and repo_url</li> <li>theme logo: media/{custom}-logo.png</li> <li>analytics: provider: google property: G-R6QYDG0126</li> <li>Copyright</li> </ul> </li> <li>platformio.ini<ul> <li>description = {custom}</li> <li>add [custom] build_flags and lib_deps</li> <li>APP_NAME=\\\"{custom}\\\" ;</li> <li>APP_VERSION=\\\"0.x.0\\\"</li> <li>CORE_DEBUG_LEVEL=4</li> </ul> </li> <li>README.md<ul> <li>Custom intro</li> </ul> </li> <li>vite.config.ts<ul> <li>Set target: 'http://192.168.1.xxx'</li> </ul> </li> <li>setup custom code<ul> <li>src/custom</li> <li>interface/src/routes/moonbase</li> <li>interface/src/lib/components/moonbase</li> <li>interface/src/lib/types/moonbase_model.ts</li> <li>interface/src/lib/stores/moonbase_utilities.ts</li> </ul> </li> <li>Github repo<ul> <li>change license</li> <li>change description</li> <li>change webhook</li> </ul> </li> </ul>"},{"location":"general/development/","title":"MoonLight Development","text":""},{"location":"general/development/#developing","title":"Developing","text":"<ul> <li>Read the ESP32 Sveltekit docs</li> <li>Read Customizing Sveltekit</li> <li>Instead of cloning the repo directly from MoonLight as described above, create a fork first so you have your own environment to make changes to. See also Pull Requests below.</li> <li>UI dev: configure vite.config.ts, go to interface folder, npm install, npm run dev. A local webserver starts on localhost. UI changes will directly be shown via this webserver</li> <li>Changes made to the UI are not always visible in the browser, issue with caching / max-age (WIP), clear the browser cache to see latest UI.</li> <li>Serial Log shows which code is from which library using emoji:</li> </ul> <pre><code>* \ud83d\udc3c: ESP-SvelteKit\n* \ud83d\udd2e: PsychicHTTP\n* \ud83d\udc38: Live Scripts\n* \ud83c\udf19: MoonBase\n* \ud83d\udcab: MoonLight\n\ud83c\udf19 and \ud83d\udcab is also used in code comments of ESP32-SvelteKit to show where changes to upstream have been made.\n</code></pre> <ul> <li>The following ESP32-SvelteKit features have been switched off in the default builts (they can be switched on if you want to use them, see features.ini)<ul> <li>-D FT_SECURITY=0</li> <li>-D FT_SLEEP=0</li> <li>-D FT_BATTERY=0</li> </ul> </li> </ul>"},{"location":"general/development/#installation-developer","title":"Installation - Developer","text":"<ul> <li>Open GitKraken (or any other GitHub client). Press + / New tab and select Clone a Repo (Or another git management tool)</li> <li>Select the folder on your local drive where to copy to (e.g. /github/ewowi)</li> <li>Copy MoonLight.git and paste in the URL field of GitKraken</li> <li>Press clone the repo</li> <li>Open VSCode</li> <li>Install the PlatformIO IDE extension, if not already done so.</li> <li>Open the folder created with GitKraken</li> <li>Connect an ESP32 or an ESP32-S3 with USB to your computer</li> <li>On the status bar select the env to flash and the board to flash to<ul> <li>Select esp32dev for a normal ESP32</li> <li>Select esp32-s3-devkitc-1-n16r8v for an ESP32-S3 (recommended or similar)</li> </ul> </li> </ul> <ul> <li>Press PlaformIO:Upload (-&gt;) on the statusbar</li> <li>The firmware is now flashed to your board, after flashing the board will reboot</li> <li> <p>Recommended: Press PlatformIO:Serial Monitor to see the debug information produced</p> </li> <li> <p>Issues</p> <ul> <li>If the board AP is not showing up in your WiFi list it might be helpful to fully erase the board before flashing (vscode \ud83d\udc7d, Erase flash)</li> <li>Sometimes the Serial log may show: [  5817][W][WiFiGeneric.cpp:1408] setTxPower(): Neither AP or STA has been started. This is from setTxPower in APSettingsService. Delay has been added to prevent this. </li> </ul> </li> </ul>"},{"location":"general/development/#pull-requests","title":"Pull Requests","text":"<ul> <li> <p>Want to make changes: fork the repo and submit pull requests, see creating-a-pull-request-from-a-fork:</p> <ul> <li>Login to your own github account</li> <li>Fork: go to MoonModules/MoonLight and press Fork, uncheck 'Copy the main branch only' and press Create Fork. You will be moved to your fork of MoonLight</li> <li>Press Branches, press New Branch, give it a name e.g. background-script and press Create new Branch, click on background-script</li> </ul> <p></p> <ul> <li>Go to the file you want to change press edit and make the changes. E.g. change executable.execute(\"main\") to executable.executeAsTask(\"main\")</li> <li>Press Commit Changes..., enter a commit message and an extended description, Press Commit Changes</li> <li>Go back to the homepage of your fork myfork/MoonLight. There is a message inviting to create a Pull Request. Press Compare &amp; pull request.</li> </ul> <p></p> <ul> <li>Add a title and Description to the Pull Request and press Create Pull Request</li> <li>Note: coderabbit has been installed on this repo, adding intelligent comments in the PR</li> </ul> <p></p> <ul> <li>The upstream MoonLight repo can now process this PR</li> </ul> </li> </ul>"},{"location":"general/development/#adding-functionality","title":"Adding functionality","text":""},{"location":"general/development/#ui","title":"UI","text":"<p>\ud83d\udea7 * nodejs * /interface folder * npm install and npm run dev * WWWData.h</p>"},{"location":"general/development/#server","title":"Server","text":"<p>There are 3 levels to add functionality:</p> <ul> <li>Standard ESP32-Sveltekit code, e.g. Connections, Wifi and System. MoonBase files is also made using standard sveltekit as example but contains a few components used in MoonLight modules. Might be rewriteen as MoonLight Module in the future.</li> <li>MoonLight Modules e.g. Light Control, Editor, Info, Channel View. They are subclasses of Modules.h/cpp and implement setupDefinition, onUpdate and optional loop. New modules need to be defined in main.cpp and added to menu.svelte. All further UI is generated by Module.svelte.</li> <li>MoonLight Nodes: the easiest and recommended way. See Effects.h, Layouts.h, Modifiers.h and Mods.h for examples. They match closest WLED usermods. Each node has controls, a setup and a loop and can be switched on and off. For specific purposes hasLayout and hasModifier can be set.</li> </ul>"},{"location":"general/gettingstarted/","title":"Getting started","text":"<p>\ud83d\udea7</p> <ul> <li>Install MoonLight</li> <li>Run MoonLight<ul> <li>Lights control</li> <li>Editor</li> </ul> </li> <li>Start developing for MoonLight<ul> <li>ESP32 Sveltekit</li> </ul> </li> </ul>"},{"location":"general/hardware/","title":"MoonLight hardware","text":""},{"location":"general/hardware/#moonlight-specific","title":"MoonLight specific","text":"<p>\ud83d\udea7</p> <ul> <li>Buy some hardware e.g.:<ul> <li>ESP32-S3 N16R8</li> <li>256 led panel</li> <li>Expansion board 44pin</li> </ul> </li> <li>For latest DMX support <ul> <li>Pknight Art-Net DMX 512</li> <li>Toy Moving heads (warning: projected lights show the individual rgb colors)</li> <li>Recommended moving heads</li> </ul> </li> </ul> <p></p>"},{"location":"general/installation/","title":"MoonLight Installation","text":"<p>Install Moonlight onto an ESP32 using the MoonLight Web installer</p> <ul> <li> <p>Step 1: Get an ESP32 or ESP32-S3 (preferred, support large setups and Live Scripts). Boards we use are ESP32 or ESP32-S3, but most of the ESP32 and ESP32-S3 boards will work. Get a WS2812 LED-strip or a LED-panel (preferred to see 2D effects). Connect the strip or panel to the board on a suitable pin (e.g. Pin 2 or 16).</p> </li> <li> <p>Step 2: Connect an ESP32(-S3) via USB</p> </li> <li> <p>Step 3: Click this link to go to the web installer: ESP Web Installer for MoonLight v0.5.6. The Web Installer works on Google Chrome or Microsoft Edge or similar browsers. Safari does not support installing things on ESP devices. Driver software might be needed to have the webinstaller recognise the board. The installer detects the board automatically. If you try to install and no boards are detected, a screen will popup inviting you to install the driver. Press Connect. You should see the ESP32 board (if not sure disconnect and connect and see which serial port is used):</p> </li> </ul> <p></p> <ul> <li>Step 4: Connect to the board, then select Install MoonLight</li> </ul> <p></p> <ul> <li>Step 5: Choose to erase the board first or not. Erase if you have a new board or want to start fresh. Do not erase if you want to update an existing MoonLight installation. Erase deletes all settings and requires to re-connect to WiFi.</li> </ul> <p></p> <ul> <li>Step 6: Confirm and install</li> </ul> <p> </p> <ul> <li>Step 7: Optionally Press Logs and Console</li> </ul> <p></p> <p>You can see the serial logging of the board. In case you see nothing you can press reset board, now you should see the logging.</p> <ul> <li>Step 8: Make a WiFi connection to the board, it should present itself in the list of WiFi access points.</li> </ul> <p></p> <ul> <li>Step 9: After connecting, MoonLight will show up in a web browser (all browsers supported). A new install will take some time to show up (up to a minute or sometimes 2). On some browsers, e.g. Safari, MoonLight pops up showing Connection to device lost repeatedly (bug). In that case, close this browser window and open MoonLight in a browser using 4.3.2.1 as URL. You will see this screen, select WiFi Station.</li> </ul> <p></p> <ul> <li>Step 10: Enter your local WiFi network credentials:</li> </ul> <p></p> <ul> <li>Step 11: Press Add Network and apply settings. After connecting to your local WiFi network you will see this screen showing the new IP address of your MoonLight board. If you don't know the IP address of your board anymore you can go to step 3 and 4 and step 7 and check the IP address in the Serial logging. Advanced tip: Use ESP32Instances to discover the ESP32 nodes on your network (using nodeJS and html)</li> </ul> <p></p> <ul> <li>Step 12: Go to your WiFi settings and connect to your local WiFi network and enter the IP address of your MoonLight board in a browser and go to MoonLight Editor. Add a layout Node by pressing the blue + button and select Panel \ud83d\udea5. Scroll down to the Pin Control field and enter the pin number you connected the strip or panel to in Step 1. After setting the right pin the strip or panel should show lights.</li> </ul> <p></p> <ul> <li> <p>That's it. You can now change effect nodes, or add nodes. For audio add the AudioSync node. More how to's will be added. At the moment:</p> <ul> <li>Check the help pages on this documentation site, especially the editor page</li> <li>press the ? in MoonLight to go directly to the relevant page    More how to's will be added. At the moment:</li> <li>Live scripts: how to run a live script</li> </ul> </li> <li> <p>Made using esp-web-tools</p> </li> <li>See also ESP-Web-Tools-Tutorial</li> </ul>"},{"location":"general/pull-requests/","title":"Pull-Requests","text":"<p>MoonLight has made a number of commits which are general purpose and could be added to upstream ESP32 SvelteKit. Pending changes are ready to add in pull-requests as they are branched from the upstream repo. Below lists are ordered in terms of likelyhood to be accepted:</p>"},{"location":"general/pull-requests/#pending-ready-to-pr","title":"Pending - Ready to PR","text":"<ul> <li>\ud83d\udc1b bug-metadata-parent-wifi: avoid console.log errors</li> <li>\u26a0\ufe0f components-small-fixes: avoid console.log errors</li> <li>\u26a0\ufe0f compile-warnings: role and tab index</li> <li>\ud83d\udca1 service-name-string: Allow service names to be non string literals (e.g. done in MoonBase-Modules)<ul> <li>\u26a0\ufe0f EventSocket emitEvent: use String type</li> </ul> </li> <li>\u26a0\ufe0f no-emit-no-clients</li> <li>\ud83d\udca1 system-status-metrics: use max instead of first</li> <li>\ud83d\udca1 help-to-docs: Help link to github.io docs e.g. editor</li> <li>\ud83d\udca1 System metrics<ul> <li>Loops per second (performance)</li> </ul> </li> <li>\ud83d\udca1 System status<ul> <li>Loops per second (performance)</li> </ul> </li> <li>\ud83d\udca1 menu-href-unique: Allow multiple modules using same Module.svelte</li> <li>\ud83d\udca1 measure-battery-pin</li> </ul>"},{"location":"general/pull-requests/#pending-wip","title":"Pending - WIP","text":"<ul> <li>File Manager</li> <li>Instances</li> <li>MoonBase-Modules</li> </ul>"},{"location":"general/pull-requests/#submitted","title":"Submitted","text":"<ul> <li>None ATM</li> </ul>"},{"location":"general/pull-requests/#merged-into-esp32-sveltekit","title":"Merged into ESP32-Sveltekit","text":"<ul> <li>Expands menu on selected subitem</li> <li>Add file.close in fileHandler handleRequest</li> <li>Refactor System Status and Metrics<ul> <li>Add free_psram, used_psram and psram_size in Analytics (models.ts) and analytics_data (analytics.ts) and show in UI (SystemMetrics.svelte)</li> <li>Send psram data only if psramFound (SystemStatus.svelte, AnalyticsService.h, SystemStatus.cpp)</li> </ul> </li> <li>Wifi: Multiple edits bug resolved</li> <li>ESPD_LOGx: replace first argument with TAG and define TAG as \ud83d\udc3c</li> </ul>"},{"location":"general/pull-requests/#other-improvements","title":"Other improvements","text":"<ul> <li>Add esp32-s3-devkitc-1-n16r8v and LOLIN_WIFI_FIX in pio.ini (including boards folder)</li> <li>Add Monitor<ul> <li>socket.ts: add else listeners.get(\"monitor\")?.forEach((listener) =&gt; listener(new Uint8Array(message.data)));</li> <li>EventSocket.cpp: add void EventSocket::emitEvent with char * argument</li> </ul> </li> <li>Add MoonBase / MoonLight specific functionality</li> <li>ESP32SvelteKit.cpp: <ul> <li>CPU load (and main.cpp)</li> <li>comment response.addHeader(\"Cache-Control\", \"public, immutable, max-age=31536000\");</li> </ul> </li> <li>interface/source/routes/+layout.svelte<ul> <li>Show monitor only on moon functions (so captive portal on small screen looks fine): #if (page.data.features.monitor &amp;&amp; page.url.pathname.includes(\"moon\"))</li> </ul> </li> <li>main.cpp: esp_log_set_vprintf(my_vprintf); WIP</li> <li>ci pio</li> <li>run in loopTask to avoid stack size crashes in httpd</li> <li>updatedItems (to see what specifically has been updated)</li> </ul>"},{"location":"moonbase/FileManager/","title":"File Manager","text":""},{"location":"moonbase/FileManager/#functional","title":"Functional","text":"<ul> <li>Navigate through folders</li> <li>create files and folders</li> <li>edit and upload files (see FileEdit)</li> </ul>"},{"location":"moonbase/FileManager/#technical","title":"Technical","text":"<ul> <li>filesState: all files on FS</li> <li>folderList: all files in a folder</li> <li>editableFile: current file</li> <li>getState / postFilesState: get filesState and post changes to files (update, delete, new)</li> <li>addFile / addFolder: create new items</li> <li>breadcrumbs(String): folder path as string array and as string, also stored as cookie</li> <li>folderListFromBreadCrumbs: create folderList of current folder</li> <li>handleEdit: when edit button pressed: navigate back and forward through folders, edit current file</li> <li>confirmDelete: when delete button pressed</li> <li>socket files / handleFileState (-&gt;folderListFromBreadCrumbs)</li> </ul> <p>Using component FileEdit, see Components</p>"},{"location":"moonbase/FileManager/#server","title":"Server","text":"<p>FileManager.h and FileManager.cpp</p>"},{"location":"moonbase/FileManager/#ui","title":"UI","text":"<p>Files.svelte</p>"},{"location":"moonbase/general/","title":"General","text":""},{"location":"moonbase/general/#functional","title":"Functional","text":"<p>\ud83d\udea7</p> <ul> <li>MoonLight Modules</li> <li>File Manager</li> <li>Instances</li> </ul>"},{"location":"moonbase/general/#technical","title":"Technical","text":""},{"location":"moonbase/general/#server","title":"Server","text":""},{"location":"moonbase/general/#ui","title":"UI","text":""},{"location":"moonbase/modules/","title":"Modules","text":""},{"location":"moonbase/modules/#functional","title":"Functional","text":"<p>A module is a generic building block to create server and UI functionality which can be activated through the menu.</p> <p>MoonBase-Modules are inspired by WLED usermods, further developed in StarBase and now in MoonLight (using the ESP32-Sveltekit infrastructure)</p> <p>See Demo, Instances and Editor for examples</p> <p>Press the ? on any module to go to the documentation.</p>"},{"location":"moonbase/modules/#technical","title":"Technical","text":"<p>With Moonbase Modules it is possible to create new module entirely from one c++ class by only defining a json document describing the data structure and a function catching all the changes in the data. Http endpont and websockets are created automatically. There is no need to create any UI code, it is entirely driven by the json document.</p> <p>Each module has each own documentation which can be accessed by pressing the ? and is defined in the docs folder.</p> <p>To create a new module:</p> <ul> <li>Create a class which inherits from Module</li> <li>Call the Module constructor with the name of the module.<ul> <li>This name will be used to set up http rest api and webserver sockets</li> </ul> </li> </ul> <pre><code>class ModuleDemo : public Module\n{\npublic:\n\nModuleDemo(PsychicHttpServer *server\n      , ESP32SvelteKit *sveltekit\n      , FileManager *fileManager\n    ) : Module(\"demo\", server, sveltekit) {\n        ESP_LOGD(TAG, \"constructor\");\n    }\n}\n</code></pre> <ul> <li>Implement function setupDefinition to create a json document with the datastructure<ul> <li>Store data on the file system</li> <li>Generate the UI</li> <li>Initialy create the module data</li> </ul> </li> </ul> <pre><code>void setupDefinition(JsonArray root) override{\n    JsonObject property; // state.data has one or more properties\n    JsonArray details; // if a property is an array, this is the details of the array\n    JsonArray values; // if a property is a select, this is the values of the select\n\n    property = root.add&lt;JsonObject&gt;(); property[\"name\"] = \"hostName\"; property[\"type\"] = \"text\"; property[\"default\"] = \"MoonLight\";\n    property = root.add&lt;JsonObject&gt;(); property[\"name\"] = \"connectionMode\"; property[\"type\"] = \"select\"; property[\"default\"] = \"Signal Strength\"; values = property[\"values\"].to&lt;JsonArray&gt;();\n    values.add(\"Offline\");\n    values.add(\"Signal Strength\");\n    values.add(\"Priority\");\n\n    property = root.add&lt;JsonObject&gt;(); property[\"name\"] = \"savedNetworks\"; property[\"type\"] = \"array\"; details = property[\"n\"].to&lt;JsonArray&gt;();\n    {\n        property = details.add&lt;JsonObject&gt;(); property[\"name\"] = \"SSID\"; property[\"type\"] = \"text\"; property[\"default\"] = \"ewtr\"; property[\"min\"] = 3; property[\"max\"] = 32; \n        property = details.add&lt;JsonObject&gt;(); property[\"name\"] = \"Password\"; property[\"type\"] = \"password\"; property[\"default\"] = \"\";\n    }\n\n}\n</code></pre> <ul> <li>Implement function onUpdate to define what happens if data changes<ul> <li>struct UpdatedItem defines the update (parent property (including index in case of multiple records), name of property and value)</li> <li>This runs in the httpd / webserver task. To run it in the main (application task use runInLoopTask - see ModuleEditor) - as httpd stack has been increased runInLoopTask is less needed</li> </ul> </li> </ul> <pre><code>    void onUpdate(UpdatedItem &amp;updatedItem) override\n    {\n        if (updatedItem.name == \"lightsOn\" || updatedItem.name == \"brightness\") {\n            ESP_LOGD(TAG, \"handle %s = %s -&gt; %s\", updatedItem.name, updatedItem.oldValue.c_str(), updatedItem.value.as&lt;String&gt;().c_str());\n            FastLED.setBrightness(_state.data[\"lightsOn\"]?_state.data[\"brightness\"]:0);\n        } else if (updatedItem.parent[0] == \"nodes\" &amp;&amp; updatedItem.name == \"name\") {    \n            ESP_LOGD(TAG, \"handle %s = %s -&gt; %s\", updatedItem.name, updatedItem.oldValue.c_str(), updatedItem.value.as&lt;String&gt;().c_str());\n            if (updatedItem.oldValue.length())\n                ESP_LOGD(TAG, \"delete %s ...\", updatedItem.oldValue.c_str());\n            if (updatedItem.value.as&lt;String&gt;().length())\n                compileAndRun(updatedItem.value);\n        } else\n            ESP_LOGD(TAG, \"no handle for %s.%s[%d] = %s -&gt; %s\", updatedItem.parent[0], updatedItem.name, updatedItem.index[0], updatedItem.oldValue.c_str(), updatedItem.value.as&lt;String&gt;().c_str());\n    }\n</code></pre> <ul> <li>Implement function loop1s to send readonly data from the server to the UI<ul> <li>Optionally, only when a module has readonly data</li> </ul> </li> </ul> <pre><code>    void loop1s() {\n        if (!_socket-&gt;getConnectedClients()) return; \n\n        JsonDocument newData; //to only send updatedData\n        JsonArray scripts = newData[\"scripts\"].to&lt;JsonArray&gt;(); //to: remove old array\n        LiveScriptNode node;\n        node.getScriptsJson(scripts);\n\n        //only if changed\n        if (_state.data[\"scripts\"] != newData[\"scripts\"]) {\n            _state.data[\"scripts\"] = newData[\"scripts\"]; //update without compareRecursive -&gt; without handles\n            update([&amp;](ModuleState &amp;state) {\n                return StateUpdateResult::CHANGED; // notify StatefulService by returning CHANGED\n            }, \"server\");\n        }\n    }\n</code></pre> <ul> <li>Add the module in main.cpp</li> </ul> <pre><code>ModuleDemo moduleDemo = ModuleDemo(&amp;server, &amp;esp32sveltekit, &amp;fileManager);\n...\nmoduleDemo.begin();\n...\nmoduleDemo.loop();\n...\nmoduleDemo.loop1s();\n</code></pre> <ul> <li>Add the module in menu.svelte (this will be automated in the future)</li> </ul> <pre><code>submenu: [\n   {\n      title: 'Module Demo',\n      icon: BulbIcon,\n      href: '/moonbase/module?module=demo',\n      feature: page.data.features.moonlight,\n   },\n]\n</code></pre> <ul> <li>This is all to create a fully functioning new module</li> </ul>"},{"location":"moonbase/modules/#readonly-data","title":"Readonly data","text":"<p>A module can consist of data which is edited by the user (e.g. selecting a live script to run) and data which is send from the server to the UI (e.g. a list of running processes). Currently both type of valuas are stored in state data and definition. Distinguished by property[\"ro\"] = true in setupDefinition. So the client uses state data and definition to build a screen with both types visually mixed together (what is desirable). Currently there are 2 websocket events: one for the entire state (including readonly) and one only for readonly which only contains the changed values. Module.svelte handles readonly differently by the function handleRO which calls updateRecursive which only update the parts of the data which has changed.</p> <p>It might be arguable that readonly variables are not stored in state data.</p>"},{"location":"moonbase/modules/#server","title":"Server","text":"<ul> <li>Module.h and Module.cpp will generate all the required server code</li> </ul>"},{"location":"moonbase/modules/#ui","title":"UI","text":"<ul> <li>Module.svelte will deal with the UI</li> <li>MultiInput.svelte is used by Module.svelte to display the right UI widget based on what is defined in the definition json</li> <li>Modifications done in menu.svelte do identify a module by href and not by title alone</li> </ul>"},{"location":"moonbase/module/ChannelView/","title":"Channel View","text":""},{"location":"moonbase/module/ChannelView/#functional","title":"Functional","text":"<p>Shows each channel within the light array. e.g. for a LED strip or panel each light is 3 (or 4 in case of RGBW) channels. For multichannel lights like Moving heads. If you hover over a channel, that channel will output a value - by this you can reverse engineer positions of existing lights, e.g. when you output to an unknown DMX setup.</p> <ul> <li>View: select between physical layer and virtual layer(s)</li> <li>Group: group all channels in a light as one button. Pressing the button sets all the channels to max</li> </ul> <p>Choosing the virtual layer and hovering over the channels is a good way to test effect modifiers</p> <p>hint: do not run effects when using the channel view as they will also fill the channels with data (set them to off in the editor)</p>"},{"location":"moonbase/module/ChannelView/#technical","title":"Technical","text":"<ul> <li>See Modules</li> </ul>"},{"location":"moonbase/module/ChannelView/#server","title":"Server","text":"<p>ModuleChannelView.h</p>"},{"location":"moonbase/module/ChannelView/#ui","title":"UI","text":"<p>Generated by Module.svelte</p>"},{"location":"moonbase/module/MoonLightInfo/","title":"MoonLight info","text":""},{"location":"moonbase/module/MoonLightInfo/#functional","title":"Functional","text":"<p>Shows info about the physical and virtual layer</p> <ul> <li>NrOfLights: the nr of lights defined in the layer</li> <li>Channels per light: e.g. normal RGB strip/panel is 3 channels per light</li> <li>Chipset: FastLED chipset defined (for FastLED hardcoded in the firmware ...)</li> <li>Size: the outer bounds of the fixture, e.g. for a 16x16 panel it is 16x16x1</li> <li>Layers: The virtual layers defined (currently only 1)<ul> <li>NrOfLights and size: virtual layer can differ from the physical layer (.e.g when mirroring it is only half)</li> <li>Color#: the number of lights which are not mapped to a physical pixel (color is stored in the mapping table)</li> <li>Phys#: The number of lights which have a 1:1 mapping between physical and virtual (if no modifier all is phys)</li> <li>Mapping table indexes: The number of physical lights which are in a 1:many mapping</li> <li>Phys M: the number of virtual lights which are in a 1:many mapping</li> <li>Nodes#: The number of nodes assigned to a virtual layer (currently all)</li> </ul> </li> </ul>"},{"location":"moonbase/module/MoonLightInfo/#technical","title":"Technical","text":"<ul> <li>See Modules</li> <li>Chipset: See pio.ini</li> </ul>"},{"location":"moonbase/module/MoonLightInfo/#server","title":"Server","text":"<p>ModuleMoonLightInfo.h</p>"},{"location":"moonbase/module/MoonLightInfo/#ui","title":"UI","text":"<p>Generated by Module.svelte</p>"},{"location":"moonbase/module/editor/","title":"Editor module","text":""},{"location":"moonbase/module/editor/#functional","title":"Functional","text":"<p>The editor allows you to define the tasks to run an effect  (e.g. bouncing balls), to modify the effect (e.g mirror), to send it to a layout (e.g. a panel 16x16) and to run supporting processes (e.g. audiosync to run sound reactive effects). Each task is defined as a node. A node can be precompiled in the firmware or defined by a live script loaded onto the File System (See File Manager). A node can be switched on and off and has custom controls, which defines the parameters of the node (e.g. effect speed).</p> <p>Ultimately the nodes will be displayed in a graphical interface where nodes are connected by 'noodles' to define dependencies between nodes. For the time being nodes will be shown in a list.</p> <p>Typically a node will define a layout (\ud83d\udea5), or an effect (\ud83d\udd25), or a modifier (\ud83d\udc8e) or a supporting process (\u2638\ufe0f) but can also combine these tasks (experimental at the moment). To avoid duplication it's in most cases recommended to keep them separated so an effect can run on multiple layouts and a modifier can modify any effect. </p> <ul> <li> <p>Layout \ud83d\udea5: a layout defines what lights are connected to MoonLight. It defines the coordinates of all lights (addLight) and assigns lights to the GPIO pins of the ESP32 (addPin) and how many channels each light has (normal LEDs 3: Red, Green and Blue). </p> <ul> <li>The coordinates of each light are defined in a 3D coordinate space where each coordinate range between 1 and 255. Currently a strip until 255 leds is supported, a panel until 128x96 LEDS and a cube max 20x20x20. <ul> <li>Coordinates needs to be specified in the order the lights are wired so MoonLight knows which light is first, which is second etc.</li> <li>If a 1D strip is longer, you can address more leds by pretending it is a 2D fixture, e.g. 32x32 to address a strip of 1024 LEDs. </li> <li>In the future we might look at redefining Coord3D where width is 12 bytes, height is 7 bytes and depth is 5 bytes allowing for max 4096 x 128 x 32 ...</li> </ul> </li> <li>Currently pins are by default driven by FastLED.show. FastLED needs all LEDs specifications be defined at compile time, e.g. LED type, color order, etc. Normally also the pin(s) need to be defined beforehand but all pins are predefined in the code to avoid this (at a cost of larger firmware). As we want to be able to define all LED specs in the UI instead of during compile, we need to see how / if this can be done.</li> <li>\ud83c\udd95 Multiple layout nodes can be defined which will execute one after the other</li> <li>In the future, instead of pins, also IP addresses and universes can be specified to support sending lights data to Art-Net devices - e.g. Pknight Art-Net DMX 512 to control DMX lights or Art-Net LED controller to control LED strips or panels over local network. Currently this is handled by the Art-Net Node.</li> <li>Alternatively Moonlight supports 2 other drivers: Physical Driver and Virtual Driver. Firmware ending with PD or VD will have this enabled. Code has been included but not tested yet (tested in StarLight), this is planned for June/July. <ul> <li>The physical driver is an alternative to the FastLED driver and does not need LED specifications defined at compile time, all can be controlled via UI. </li> <li>The virtual driver is another beast and with the help of shift registers allows for driving 48 panels of 256 LEDs each at 100 FPS!.</li> </ul> </li> <li>MoonLight will use the layout definition to generate a mapping of a virtual coordinate space to a physical coordinate space. Most simple example is a panel which has a snake layout. The mapping will create a virtual layer where the snake layout is hidden.</li> </ul> </li> <li> <p>Effect \ud83d\udd25: An effect runs in a virtual layer (see above about mapping to a physical layer). Historically there are 1D, 2D and 3D effects. A 1D effect only fills leds in x space, leaving y and z blank. 2D also the y space, 3D all spaces. Future goal is that all effects fill all spaces (example is bouncing balls which was a 1D effect but has been made 2D). See also Modifiers which can take a 1D effect and make a 2D or 3D effect out of it: e.g. a 1D effect can be presented as a circle, or sphere.</p> <ul> <li>An effect has a loop which is ran for each frame produced. In each loop, the lights in the virtual layer gets it's values using the setRGB function. For multichannel lights also functions as setWhite or (for Moving Heads) setPan, setTilt, setZoom etc. Also getRGB etc functions exists.</li> <li>Multiple effects can be defined, they all run during one frame. In the future each effect will have a start and end coordinate so they can also be displayed on parts of the fixture.</li> </ul> </li> <li> <p>Modifier \ud83d\udc8e: a modifier is an effect on an effect. It can change the size of the virtual layer, it can map the pixels other then 1:1 (e.g. mirror, multiply them or a 1D line can become a 2D circle) and it can change each light set in an effect during a loop (e.g. rotate the effect)</p> <ul> <li>Multiple modifiers are allowed, e.g. to first rotate then mirror (or first mirror then rotate). The UI allows for reordering nodes.</li> </ul> </li> </ul> <p>See Nodes page for documentation on existing nodes</p>"},{"location":"moonbase/module/editor/#archive","title":"Archive","text":"<p>This page is \ud83d\udea7, text below will be rewritten.</p>"},{"location":"moonbase/module/editor/#qa","title":"Q&amp;A","text":"<p>Collecting questions and answers (from Discord) WIP !!</p> <ul> <li>I'm therefore wondering if esplive only supports xtensa ASM and not RISCV? we're actually not supposed to enable esplivescript on anything else than the s3. For the moment it\u2019s esp32 , esp32 s2 esp32s3. I am revamping the compiler for it to be more compact and less memory hungry. Once that is done I will work on creating risc assembly language so it can be used with the esp32 C family and also I want to do arm for the pi pico.</li> <li>Technically live scripts works on normal esp32, but MoonLight with live scripts is 103% flash size. I didn\u2019t look into other partitioning (preferably keeping Ota working): note use esp32 16MB!!</li> <li>why do some animations allow me to specifiy the led strip pin but not others?</li> <li>is there a wiki page I can read for me to understand pin mapping and led strip physical format?  there are layout nodes \ud83d\udea5 (defining how the lights layed out in a matrix, cube etc. There you can define pins) effect nodes \ud83d\udd25 (obviously) and modifier nodes \ud83d\udc8e(modify an effect)</li> <li>how does the lights control module interact with the animations module?</li> <li>what does \"snake\" mean for a moving head configuration?</li> <li>how do i specify which solid color i want? Added!</li> <li>getting a few \"Software reset due to exception/panic\" depending on the effects i set \ud83d\ude04 but that might be my PSU</li> <li>how I can specify the color order.... I see the define I want in fastled.h, i'm guessing it's passed somehow to the template through maybe the ML_CHIPSET define? oh.... it seems to require a modification of void LedsDriver::init sorry for the spam.... it also looks to me that even with the ML_CHIPSET=SK6812 define there's no support for RGBW as on a small led strip, setting a solid color of red for example, i see green &amp; white - blue - red - green &amp; white - blue - red (eg: it's forgetting to send 4x 8b per led)</li> <li>is the monitor only available with the s3? I enabled \"Monitor On\" in the control tab oh that's interesting, the platform booted full white (when configured in solid animation) but went back to what was supposed to be when I started moving the control sliders. should be working on all platforms</li> <li>not sure if this has been flagged, but when changing a selected node type, the parameters of the previous node will stay displayed and when switching node types, I did manage to get LEDs frozen (impossible to get them ot update again) it takes a platform reboot, and changing the movinghead number of LEDs in my case. it looks like some refresh isn't happening. even the platform reboot trick sometimes isn't happening... looking at the console output i'm seeing that my actions on the user interface aren't registered</li> <li>how complex would it be to map several led strips on several IOs to a virtual 2d matrix? I'm currently looking at the code, more particularly void mapLayout() and it seems the layout is reset every time that function is called, so it is not possible to increase the display size</li> <li>single line and row layouts</li> <li>personally i'd make 2 different menus in the esp32 GUI.. a layout is more something you set and forget about as it is tied to a physical install</li> <li>one layout to define all the lights is definitely a blocker for me (and I imagine more people) as physical installs have their own constraints. let me know what you think. I will add that possibility , I see \u2018some\u2019 usage, but I don\u2019t understand why it is a blocker as in general the whole setup is a number of lights which you know in advance so then it is most clear to define that in one go ?</li> </ul>"},{"location":"moonbase/module/editor/#technical","title":"Technical","text":"<ul> <li> <p>Nodes</p> <ul> <li>See Nodes.h: class Node<ul> <li>name(): name of the node</li> <li>hasFunctions: enables features of the Node (Layout, Modifier)</li> <li>on: (de)activates the node</li> <li>constructor: sets the corresponding layer</li> <li>setup: if layout sets channelsPerLight and request map</li> </ul> </li> <li>Nodes manipulate the leds / channels array and the virtual to physical layer mappings.</li> <li>specify which functions (layout, effect, modifier): One node in general implements one, but can also implement all three (e.g. Moving Head...  wip...)<ul> <li>layout</li> <li>effect</li> <li>modifier</li> </ul> </li> <li>Live scripts<ul> <li>See Nodes.h / nodes.cpp</li> </ul> </li> <li>Lights<ul> <li>Regular patterns (CRGB as default but also others like Moving Head ...)</li> </ul> </li> </ul> </li> <li> <p>See Modules</p> </li> <li>Upon changing a pin, driver.init will rerun (FastLED.addLeds, PD and VD driver.init)</li> <li>Uses ESPLiveScripts, see compileAndRun. compileAndRun is started when in Nodes a file.sc is choosen<ul> <li>To do: kill running scripts, e.g. when changing effects</li> </ul> </li> <li>Nodes.h: class Node (constructor, destructor, setup, loop, hasFunctions, map, modify, addControl(s), updateControl)</li> <li>Nodes.cpp: implement LiveScriptNode</li> </ul>"},{"location":"moonbase/module/editor/#mapping-model-wip","title":"Mapping model (WIP)","text":"<ul> <li>Multiple Nodes can be created (1)<ul> <li>Each node can have controls (compare controls in WLED / StarLight) \u2705</li> <li>Each node can run precompile code or Live scripts (with or without loop) \u2705</li> <li>Each node has a type:<ul> <li>Layout: tell where each light is in a 1D/2D/3D physical coordinate space (based on StarLight fixtures) \u2705</li> <li>Effect: <ul> <li>run an effect in a virtual coordinate space \u2705</li> <li>in the physical space if you want to run at highest performance, e.g. a random effect doesn't need to go through mappings \u2705</li> </ul> </li> <li>Modifier: Mirror, rotate, etc, multiple modfiers allowed (projection in StarLight) \ud83d\udea7<ul> <li>A modifier can also map lights dimensions to effect dimensions: change the lights to a 1D/2D/3D virtual coordinate space<ul> <li>e.g. if the light is a globe, you can map that to 2D using mercator projection mapping</li> <li>if the light is 200x200 you can map it to 50x50</li> <li>if the light is 2D, a 1D effect can be shown as a circle or a bar (as WLED expand1D)</li> </ul> </li> </ul> </li> <li>Driver show: show the result on Leds (using FastLED, hpwit drivers), Art-Net, DDP, ...</li> </ul> </li> </ul> </li> <li>Future situation: Nodes and noodles (2)<ul> <li>Replace the nodes table (1) by a graphical view (2)</li> </ul> </li> <li>Virtual Layer (MappingTable) (3)<ul> <li>Array of arrays. Outer array is virtual lights, inner array is physical lights. \u2705</li> <li>Implemented efficiently using the StarLight PhysMap struct \u2705</li> <li>e.g. [[],[0],[1,2],[3,4,5],[6,7,8,9]] \u2705<ul> <li>first virtual light is not mapped to a physical light</li> <li>second virtual light is mapped to physical light 0</li> <li>third virtual light is mapped to physical lights 1 and 2</li> <li>and so on</li> </ul> </li> <li>Virtual lights can be 1D, 2D or 3D. Physical lights also, in any combination<ul> <li>Using x + y * sizeX + z * sizeX * sizeY \ud83d\udea7</li> </ul> </li> <li>set/getLightColor functions used in effects using the MappingTable \u2705</li> <li>Nodes manipulate the MappingTable and/or interfere in the effects loop \ud83d\udea7</li> <li>A Virtual Layer mapping gets updated if a layout, mapping or dimensions change \ud83d\udea7</li> <li>An effect uses a virtual layer. One Virtual layer can have multiple effects. \u2705</li> </ul> </li> <li>Physical layer<ul> <li>CRGB leds[MAX_LEDS] are physical lights (as in FASTLED) \u2705</li> <li>A Physical layer has one or more virtual layers and a virtual layer has one or more effects using it. \u2705</li> </ul> </li> <li>Presets/playlist: change (part of) the nodes model</li> </ul> <p>\u2705: Done</p>"},{"location":"moonbase/module/editor/#server","title":"Server","text":"<p>ModuleEditor.h</p>"},{"location":"moonbase/module/editor/#ui","title":"UI","text":"<p>Generated by Module.svelte</p>"},{"location":"moonbase/module/instances/","title":"Instances module","text":""},{"location":"moonbase/module/instances/#functional","title":"Functional","text":"<p>Sends and receives UDP messages over the network to see which other instances are there (WLED compatible). </p> <ul> <li>Instance name: name of this instance</li> <li>Instances: Instances found on the network<ul> <li>Click on IP to jump to the instance</li> </ul> </li> </ul>"},{"location":"moonbase/module/instances/#technical","title":"Technical","text":"<ul> <li>See Modules</li> <li>Statusbar and HTML title display the instance name</li> </ul>"},{"location":"moonbase/module/instances/#server","title":"Server","text":"<p>ModuleInstances.h</p>"},{"location":"moonbase/module/instances/#ui","title":"UI","text":"<p>Generated by Module.svelte</p>"},{"location":"moonbase/module/lightsControl/","title":"Lights Control module","text":""},{"location":"moonbase/module/lightsControl/#functional","title":"Functional","text":"<p>Controls:</p> <ul> <li>On: lights on or off</li> <li>Brightness: brightness of the LEDs when on</li> <li>RGB Sliders: control each color separately.</li> <li>Palette: Global palette setting. Effects with the palette icon \ud83c\udfa8 use this palette setting.</li> <li>Presets: Control pad style, store or retrieve a set of nodes with their controls. WIP</li> <li>Driver On: sends LED output to ESP32 gpio pins.<ul> <li>Switch off to see the effect framerate in System Status/Metrics</li> <li>Switch on to see the effect framerate throttled by a LED driver in System Status/Metrics (800KHz, 256 leds, 24 bits is 130 fps theoretically - 120 practically)</li> <li>Will move to driver node later ...</li> </ul> </li> <li>Monitor On: sends LED output the monitor in the UI.</li> </ul> <p>A MoonLight instance can expose itself as an Art-Net device (DMX mode) where above controls will be the channels to control by Art-Net controllers (it can be an Art-Net DMX receiver but also an Art-Net LEDs receiver, and it can be an Art-Net sender - See Art-Net Module) - WIP (only Art-Net sender is currently implemented)</p>"},{"location":"moonbase/module/lightsControl/#technical","title":"Technical","text":"<ul> <li>Drivers<ul> <li>FastLED</li> <li>Physical driver</li> <li>Virtual driver</li> </ul> </li> </ul> <p>Light Controls is the interface to control lights for the UI, but also for all protocols eg. HA, DMX, Hardware buttons, displays etc e.g. a DMX controller, can control presets, but not individual preset details.</p> <ul> <li>See Modules</li> </ul>"},{"location":"moonbase/module/lightsControl/#server","title":"Server","text":"<p>ModuleLightsControl.h</p>"},{"location":"moonbase/module/lightsControl/#ui","title":"UI","text":"<p>Generated by Module.svelte</p>"},{"location":"moonbase/module/liveScripts/","title":"Live Scripts module","text":""},{"location":"moonbase/module/liveScripts/#functional","title":"Functional","text":"<p>MoonLight is based on nodes (see editor) where each node can run precompiled layouts, effects or modifiers but alternatively, each node can also run a live script, uploaded on the esp32 file system (.sc files). Currently this only works on esp32-S3 boards as normal esp32 boards do not have enough memory to flash MoonLight with the Live Scripts option.</p> <p>This module shows all running live scripts</p> <ul> <li>Scrips: Running Live scripts (WIP)</li> <li>Press the edit button to stop start or kill a script (current bug: double click the button)</li> </ul>"},{"location":"moonbase/module/liveScripts/#how-to-run-a-live-script","title":"How to run a live script","text":"<p>Step 1: Select Moonbase / File Manager from the menu and select a location to store live scripts. Create a folder if needed (press the second + button):</p> <p></p> <p>Step 2: Go to this folder and create a file (press the first + button). Give the file a name ending with .sc and enter the code. See github livescripts for example scripts (E_.sc files are effects L_.sc files are layouts). Alternatively you can also upload a live script with by pressing the Upload File button. Press save:</p> <p></p> <p>Step 3: Select  MoonLight / Editor from the menu. Create a new effect node (\ud83d\udd25) by pressing the + button or update an existing effect node (\ud83d\udd25) by pressing the \u2710-button. Open the drop down and scroll to the bottom where live script files are shown</p> <p></p> <p>Step 4: Select the script, the script will be compiled (takes a second or so) and executed. You can see the effect controls on the bottom of the screen (speed and branches in this example), change them to customise the effect: </p> <p></p> <p>Step 5: Live scripts can be edited in the node press the \u2710-button of a live script node and press the v next to Edit  and the same edit window as in Step 2 opens. Do your edits and press save. The  script recompiles and will restart the effect. (Alternatively if a script is running and you edit a file in the file manager, the script will also recompile and rerun). For a list of functions currently supported, see live script functions. This list is dynamic and will increase overtime, send a ping if you would like function(s) to be added. <p></p> <p>Step 6: An overview of running live scripts can be found in MoonLight / LiveScripts </p>"},{"location":"moonbase/module/liveScripts/#technical","title":"Technical","text":"<ul> <li>See Modules</li> <li>Uses ESPLiveScripts, see compileAndRun. compileAndRun is started when in Nodes a file.sc is choosen<ul> <li>To do: kill running scripts, e.g. when changing effects</li> </ul> </li> </ul>"},{"location":"moonbase/module/liveScripts/#server","title":"Server","text":"<p>ModuleLiveScripts.h</p>"},{"location":"moonbase/module/liveScripts/#ui","title":"UI","text":"<p>Generated by Module.svelte</p>"},{"location":"moonlight/general/","title":"General","text":""},{"location":"moonlight/general/#functional","title":"Functional","text":"<p>\ud83d\udea7</p> <ul> <li>Lights control</li> <li>Editor</li> <li>Live Scripts</li> <li>Channel View</li> <li> <p>MoonLight info</p> </li> <li> <p>Safe Mode: MoonBase will jump into safe mode after a crash, see System Status. In safe mode, MoonLight will disable the following features:</p> <ul> <li>Add more then 1024 lights</li> <li>Execute a live script</li> </ul> <p>This list is dynamic and will change over time if crash reasons change.</p> </li> </ul>"},{"location":"moonlight/general/#technical","title":"Technical","text":""},{"location":"moonlight/general/#server","title":"Server","text":""},{"location":"moonlight/general/#ui","title":"UI","text":""},{"location":"moonlight/nodes/","title":"Nodes","text":""},{"location":"moonlight/nodes/#emoji-coding","title":"Emoji coding:","text":"<ul> <li>\ud83d\udd25 Effect</li> <li>\ud83d\udea5 Layout</li> <li>\ud83d\udc8e Modifier</li> <li>\u2638\ufe0f Supporting node</li> <li>\ud83c\udfa8 Using palette</li> <li>\ud83d\udca1 WLED origin</li> <li>\ud83d\udcab MoonLight origin</li> <li>\u266b Audio reactive FFT based</li> <li>\u266a Audio reactive volume based</li> <li>\ud83e\uddca 3D</li> </ul>"},{"location":"moonlight/nodes/#effect-nodes","title":"Effect \ud83d\udd25 Nodes","text":"<p>\ud83d\udea7 Precompiled effects can be found in effects</p>"},{"location":"moonlight/nodes/#solid","title":"Solid \ud83d\udd25\ud83d\udca1","text":"<ul> <li>Sends a solid RGB to all lights</li> <li>Controls: Red, Green, Blue, Brightness</li> <li>Usage: Can be used as background to other effects, order it before other effects</li> </ul>"},{"location":"moonlight/nodes/#pantilt-script","title":"PanTilt script","text":"<ul> <li>Sends a beatsin to Pan and Tilt which can be sent to Moving Heads (add a Moving head layout node to configure the MHs)</li> <li>Controls: BPM, Middle Pan and Tilt, Range and invert</li> <li>Usage: Add this effect if moving heads are configured. RGB effects can be added separately e.g. wave to light up the moving heads in wave patterns</li> <li>See E_PanTilt</li> <li>Run script see How to run a live script</li> </ul>"},{"location":"moonlight/nodes/#layout-nodes","title":"Layout \ud83d\udea5 Nodes","text":"<p>\ud83d\udea7</p>"},{"location":"moonlight/nodes/#se16","title":"SE16 \ud83d\udea5","text":"<p>Layout(s) for Stephan Electronics 16-Pin ESP32-S3 board, using the pins used on the board</p> <ul> <li>ledsPerPin: the number of LEDs connected to one pin</li> <li>pinsAreColumns: are the leds on a pin a row of the effect (width is 1 (or 2) x ledsPerPin). If not set the leds are a column (height is 1 (or 2) x ledsPerPin)</li> <li>mirroredPins: If set it is assumed that LEDs are connected with increasing positions on 8 pins on one side of the board and decreasing positions on the 8 pins of the other side of the board. The resulting size will have a width of 8 and the height (or width) will be 2 * ledsPerPin. If not set, the width will be 16 and the height (or width) = ledsPerPin</li> </ul>"},{"location":"moonlight/nodes/#modifier-nodes","title":"Modifier \ud83d\udc8e Nodes","text":"<p>\ud83d\udea7</p>"},{"location":"moonlight/nodes/#pinwheel","title":"Pinwheel \ud83d\udc8e\ud83d\udca1","text":"<p>Projects 1D/2D effects onto 2D/3D fixtures in a pinwheel pattern.</p> <ul> <li>Swirl option to bend the pinwheel.</li> <li>Reverse option.</li> <li>Rotation Symmetry: Controls the rotational symmetry of the pattern.</li> <li>Petals option to adjust the number of petals.</li> <li>Ztwist option for 3D fixtures to twist the pattern along the z-axis.</li> <li>The virtual layer width is the number of petals. The height is the distance from center to corner</li> </ul>"},{"location":"moonlight/nodes/#rippleyz","title":"RippleYZ \ud83d\udc8e\ud83d\udca1\ud83d\udcab","text":"<p>Takes lights of an effect and copies them to other lights. E.g. 1D effect will be rippled to 2D, 2D effect will be rippled to 3D</p> <ul> <li>shrink: shrinks the original size to towardsY and Z</li> <li>towardsY: copies X into Y</li> <li>towardsZ: copies XY into Z</li> </ul> <p>Note: some effects already do this theirselves e.g. FreqMatrix runs on 1D but copies to 2D and 3D if size allows.</p>"},{"location":"moonlight/nodes/#supporting-nodes","title":"Supporting \u2638\ufe0f Nodes","text":"<p>\ud83d\udea7</p>"},{"location":"moonlight/nodes/#art-net","title":"Art-Net \u2638\ufe0f","text":"<p>This node sends the content of the Lights array in Art-Net compatible packages to an Art-Net controller specified by the IP address provided.</p> <ul> <li>Controller IP: The last segment of the IP address within your local network, of the the hardware Art-Net controller.</li> <li>Throttle Speed: set the max frames per second Art-Net packages are send out (also all the other nodes will run at this speed).</li> </ul> <p>Example of compatible controllers can be found here. Both Art-Net LED controllers and Art-Net DMX controllers can be used as output.</p> <p>The node supports this setup: <pre><code>    std::vector&lt;uint16_t&gt; hardware_outputs = {1024,1024,1024,1024,1024,1024,1024,1024};\n    std::vector&lt;uint16_t&gt; hardware_outputs_universe_start = { 0,7,14,21,28,35,42,49 }; //7*170 = 1190 leds =&gt; last universe not completely used\n</code></pre></p> <p>Todo:  * Add controls for other hardware_outputs * MoonLight can also act as a receiving Art-Net controller </p>"},{"location":"moonlight/nodes/#audiosync","title":"AudioSync \u2638\ufe0f \u266b","text":"<ul> <li>listens to audio sent over the local network by WLED-AC or WLED-MM and allows sound reactive effects (\u266b) to use audio data (volume and bands (FFT))</li> </ul>"},{"location":"moonlight/nodes/#creating-new-nodes","title":"Creating new nodes","text":"<p>The nodes system is in principle a general mechanism. Currently it is implemented as a MoonLight feature, might move to a generic MoonBase feature in the future. Currently it is intertwined with MoonLight functionality supporting the Physical and Virtual layer model and supporting the 4 types of nodes: Layout, effect, modifier and supporting node.</p> <p>The core node functionality supports the following</p> <ul> <li>setup() and loop()</li> <li>controls: each node has a variable number of flexible variables of different types (sliders/range, checkboxes, numbers etc). They are added with the setControl function in the setup()<ul> <li>Warning: type of controls</li> </ul> </li> <li>Firmware or live scripts</li> </ul> <p>MoonLight specific</p> <ul> <li>Node types: it is recommended that a node is one of the 4 types as described above. However each node could perform functionality of all types. To recognize what a node does the emojis \ud83d\udea5, \ud83d\udd25, \ud83d\udc8e and \u2638\ufe0f are used in the name. The variables hasLayout and hasModifier indicate the specific functionality the node supports. They control when a physical to virtual mapping is recalculated<ul> <li>hasLayout: a layout node specify the amount of position of lights controlled. E.g. a panel of 16x16 or a cube of 20x20x20. If hasLayout is defined you should implement addLayout calling addLight(position) and addPin() for all the lights. </li> <li>addPin() is needed if a LED driver is used to send the output to led strips.</li> <li>hasModifier: a modifier node which manipulates virtual size and positions and lights using one or more of the functions modifySize, modifyPosition and modifyXYZ.</li> <li>if the loop() function contains setXXX functions is used it is an effect node. It will contain for-loops iterating over each virtual ! light defined by layout and modifier nodes. The iteration will be on the x-axis for 1D effects, but also on the y- and z-axis for 2D and 3D effects. setRGB is the default function setting the RGB values of the light. If a light has more 'channels' (e.g. Moving heads) they also can be set. </li> </ul> </li> <li>Moving heads<ul> <li>addLight will show where the moving head will be on the stage. In general only an array of a few lights e.g. 4 moving heads in a row. A moving head effect will then iterate over 4 lights where each light might do something different (e.g. implement a wave of moving head movement)</li> <li>You need to define channelsPerLight in the layout node setup() - (it is default 3 to support normal LEDs). Currently MoonLight only supports identical moving heads with the same channels. The first light starts at DMX 0 (+1), the second at DMX channelsPerLight (+1) the third on DMX 2*channelsPerLight (+1) and so on. (+1): DMX typically starts at address 1 while MoonLight internal starts with 0... WIP. We are working on a solution to support different lights e.g a mix of 15 channel lights and 32 channel lights etc. You could set channelsPerLight to a higher number as the real lights channels, e.g. 32 so each lights DMX address starts at a multiple of 32.</li> <li>Layout: The layout node also defines which functionality / channels the light support by defining offsets. Currently the following offsets are supported: offsetRGB, offsetWhite, offsetBrightness, offsetPan, offsetTilt, offsetZoom, offsetRotate, offsetGobo, offsetRGB1, offsetRGB2, offsetRGB3, offsetBrightness2 and need to be set in the setup() function.</li> <li>The distinction between physical and virtual layer for moving heads is not useful if you have only 2-4 moving heads. However this is a standard MoonLight feature. It might become useful if you have like 8 (identical) moving heads, 4 left and 4 right of the stage, then you can add a mirror modifier and the virtual layer will only control 4 lights, which then will be mapped to 8 physical lights. In theory you can also have a cube of like 512 moving heads and then exotic modifiers like pinwheel could be used to really go crazy. Let us know when you have one of these setups \ud83d\udea8</li> <li>Moving heads will be controlled using the ArtNed Node. addPin is not needed for moving heads, although you might want to attach LEDs for a visual view of what is send to Art-Net.</li> <li>Effect nodes set light: Currently setRGB, setWhite, setBrightness, setPan, setTilt, setZoom, setRotate, setGobo, setRGB1, setRGB2, setRGB3, setBrightness2 is supported. In the background MoonLight calculates which channel need to be filled with values using the offsets (using the setLight function).</li> <li>If offsetBrightness is defined, the RGB values will not be corrected for brightness in ArtNed.</li> </ul> </li> </ul>"},{"location":"system/metrics/","title":"System Metrics","text":""},{"location":"system/metrics/#functional","title":"Functional","text":"<p>Shows system info on a timeline</p> <ul> <li> \ud83c\udf19 Performance: show the loops per second of the main application loop. In case of MoonLight this is the Frames Per Second.</li> <li> \ud83c\udf19 PSRAM: Shows the used size of PSRAM, if present</li> </ul>"},{"location":"system/metrics/#technical","title":"Technical","text":""},{"location":"system/metrics/#server","title":"Server","text":"<p>SystemStatus.h and SystemStatus.cpp</p>"},{"location":"system/metrics/#ui","title":"UI","text":"<p>SystemStatus.svelte</p>"},{"location":"system/status/","title":"System Status","text":""},{"location":"system/status/#functional","title":"Functional","text":"<ul> <li>\ud83c\udf19 Performance: loops per second: nr of times main loop is executed</li> <li> <p>\ud83c\udf19 Safe Mode \ud83c\udd95: After a crash, the device will start in Safe Mode disabling possible causes of crashes. See also MoonLight. In case of safe mode, the statusbar will show a shield: \ud83d\udee1\ufe0f. Try to find the reason of the crash and correct and restart the device. If no crash, it will go out of safe mode.</p> </li> <li> <p>Sleep: Device is set in low power mode.</p> </li> <li>Restart: The device will restart</li> <li>Factory reset: all settings will be removed.</li> </ul>"},{"location":"system/status/#technical","title":"Technical","text":"<ul> <li>\ud83c\udf19 Reordered info from dynamic to static</li> </ul>"},{"location":"system/status/#server","title":"Server","text":"<p>SystemStatus.h and SystemStatus.cpp</p>"},{"location":"system/status/#ui","title":"UI","text":"<p>SystemStatus.svelte</p>"},{"location":"system/update/","title":"System Update","text":""},{"location":"system/update/#functional","title":"Functional","text":"<p>New firmware releases are published on github. They are listed here. If there is a new release, the app will notify it's availability.</p> <p>Select one of the releases to install. In general it is advised to install the most recent version.</p> <p>Firmware can also be uploaded manually. Select choose file, Press Upload if asked for Are you sure you want to overwrite the existing firmware with a new one?. Wait until the connection gets lost and is re-established. Then the new firmare is installed.</p>"},{"location":"system/update/#technical","title":"Technical","text":""},{"location":"system/update/#server","title":"Server","text":"<p>SystemUpdate.h and SystemUpdate.cpp</p>"},{"location":"system/update/#ui","title":"UI","text":"<p>SystemUpdate.svelte</p>"},{"location":"wifi/ap/","title":"WiFi - Access Point","text":""},{"location":"wifi/ap/#functional","title":"Functional","text":""},{"location":"wifi/ap/#technical","title":"Technical","text":""},{"location":"wifi/ap/#server","title":"Server","text":"<p>SystemStatus.h and SystemStatus.cpp</p>"},{"location":"wifi/ap/#ui","title":"UI","text":"<p>SystemStatus.svelte</p>"},{"location":"wifi/sta/","title":"WiFi - Station","text":""},{"location":"wifi/sta/#functional","title":"Functional","text":""},{"location":"wifi/sta/#technical","title":"Technical","text":""},{"location":"wifi/sta/#server","title":"Server","text":"<p>SystemStatus.h and SystemStatus.cpp</p>"},{"location":"wifi/sta/#ui","title":"UI","text":"<p>SystemStatus.svelte</p>"}]}